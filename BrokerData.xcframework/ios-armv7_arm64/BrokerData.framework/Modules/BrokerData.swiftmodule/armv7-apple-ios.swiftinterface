// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.3 (swiftlang-1100.0.282.1 clang-1100.0.33.15)
// swift-module-flags: -target armv7-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name BrokerData
import APICore
import Alamofire
import BCSSwiftTools
@_exported import BrokerData
import Foundation
import JWTDecode
import MapKit
import Moya
import RealmSwift
import RxCocoa
import RxObservableCache
import RxSwift
import Starscream
import Swift
final public class ShortDobsServiceConfigurator : APICore.DefaultAPIServiceConfigurator {
  override public init(baseUrl: Foundation.URL)
  override public init(baseUrl: Foundation.URL, sessionManager: APICore.SessionManager = super, bodyEncoding: @escaping APICore.MethodBodyEncoding = super, plugins: [APICore.Plugin] = super, headers: [Swift.String : Swift.String]? = super, requestsErrorBehavior: APICore.RequestErrorBehavior? = super)
  @objc deinit
}
public typealias BankAccountId = Swift.Int
extension ETWithdrawService {
  public struct ClientResponse : Swift.Decodable {
    public let clientId: Swift.Int
    public let name: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct BankAccountItemResponse : Swift.Decodable {
    public let bankAccountId: Swift.Int
    public let client: BrokerData.ETWithdrawService.ClientResponse
    public let bank: BrokerData.ETDataService.BankItemResponse
    public let currency: Swift.String
    public let account: Swift.String
    public let accountType: Swift.Int
    public let payee: Swift.String
    public let payeeType: Swift.Int
    public let iNN: Swift.String?
    public let externalId: Swift.String
    public let status: Swift.Int
    public let statusDescription: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public typealias SaveBankAccountResponse = BrokerData.ETWithdrawService.DeleteBankAccountResponse
  public struct DeleteBankAccountResponse : Swift.Decodable {
    public let userRequestId: Swift.String
    public let info: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct WithdrawalSaveItemResponse : Swift.Decodable {
    public let userRequestId: Swift.String
    public let requestNum: Swift.Int
    public let recipient: Swift.String
    public let date: Foundation.Date
    public let fIO: Swift.String
    public let agreementNo: Swift.String
    public let agreementDate: Foundation.Date
    public let account: Swift.String
    public let type: Swift.String
    public let isRest: Swift.Bool
    public let tradeFloor: Swift.String
    public let amount: Swift.String?
    public let bankAccount: BrokerData.ETWithdrawService.BankAccountItemResponse
    public let message: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct BusinessError : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class ETNotificationsService : APICore.APIService<BrokerData.ETNotificationsService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case list(BrokerData.ETNotificationsService.Methods.NotificationsRequestParams)
    case save(BrokerData.ETNotificationsService.Methods.SaveRequestParams)
    case delete([BrokerData.Id])
    case markViewed([BrokerData.Id])
  }
  required public init()
  @objc deinit
}
extension ETNotificationsService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETNotificationsService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case list
    case save
    case delete
    case markViewed
    public typealias RawValue = Swift.String
    public typealias AllCases = [BrokerData.ETNotificationsService.Methods.MockKey]
    public static var allCases: [BrokerData.ETNotificationsService.Methods.MockKey] {
      get
    }
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETNotificationsService.Methods.MockKey? {
    get
  }
}
extension ETNotificationsService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
final public class QntSoftServiceConfigurator : APICore.APIServiceConfiguratorType, APICore.APIServiceConfiguratorDelegate {
  final public var requestsErrorBehavior: APICore.RequestErrorBehavior?
  final public var sessionManager: APICore.SessionManager
  final public let bodyEncoding: APICore.MethodBodyEncoding
  final public let baseUrl: Foundation.URL
  final public var plugins: [APICore.Plugin]
  final public let baseHeaders: [Swift.String : Swift.String]?
  weak final public var delegate: APICore.APIServiceConfiguratorDelegate?
  final public var token: Swift.String?
  public init(plugins: [APICore.Plugin] = [], secret: Swift.String)
  final public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  @objc deinit
}
extension BroData {
  public struct Order {
    public enum SmsConfirmResult {
      case confirmed(BrokerData.OrderId)
      case codeExpired
      case codeInvalid
      case tooManyAttempts
      case unknown
    }
    public enum TradePassConfirmResult {
      case confirmed(BrokerData.OrderId)
      case tooManyAttempts
      case codeInvalid
      case unknown
    }
  }
}
extension BroData.Order {
  public static func newOrderTradingInfo(for instrument: BrokerData.FinInstrument) -> RxSwift.Single<BrokerData.NewOrder.TradingInfo>
  public static func reserveId() -> RxSwift.Single<BrokerData.OrderId>
  public static func createOrderRequest(for newOrder: BrokerData.NewOrder, with id: BrokerData.OrderId, source: BrokerData.OrderSource? = nil) -> RxSwift.Single<BrokerData.OrderRequestId>
  public static func sendNewConfirmationSmsCode(for id: BrokerData.OrderRequestId) -> RxSwift.Single<Swift.Void>
  public static func confirmOrderRequest(_ id: BrokerData.OrderRequestId, bySmsCode code: Swift.String, agreement: Swift.String?) -> RxSwift.Single<BrokerData.BroData.Order.SmsConfirmResult>
  public static func createAndConfirm<O>(newOrder: O, with id: BrokerData.OrderId, source: BrokerData.OrderSource? = nil, byPin pin: BrokerData.PIN) -> RxSwift.Single<BrokerData.BroData.Order.TradePassConfirmResult> where O : BrokerData.NewOrder
  public static func check(pin: BrokerData.PIN) -> RxSwift.Single<BrokerData.TradePasswordCheckResult>
  public static func orderStatus(id: BrokerData.OrderId, tradingType: BrokerData.TradingType) -> RxSwift.Single<BrokerData.OrderStatus>
  public static func cancel(order: BrokerData.Order) -> RxSwift.Single<Swift.Void>
}
public struct TradeFloor {
  public let identifier: Swift.Int
  public let name: Swift.String
}
public struct NonTradeOperation {
  public let id: BrokerData.OperationId
  public let instrument: BrokerData.FinInstrument
  public let date: Foundation.Date
  public let kind: BrokerData.NonTradeOperation.Kind
  public let amount: Swift.Double
  public let price: BrokerData.Price
  public let payment: BrokerData.Money
  public let account: BrokerData.Account?
}
extension NonTradeOperation {
  public enum Kind {
    case deposit
    case withdrawal
    case otherCommissions
    case paymentOfCouponsOrDividends
    case redemptionOfBond
    case personalIncomeTax
    case exchangeCommission
    case brokerageCommission
    case otherIncome
    public static func == (a: BrokerData.NonTradeOperation.Kind, b: BrokerData.NonTradeOperation.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public enum NewsCategory : Swift.CaseIterable {
  case myNews
  case important
  case russian
  case world
  case currency
  case techAnalysis
  case analytics
  case video
  case markets
  case issuers
  case goods
  public static func == (a: BrokerData.NewsCategory, b: BrokerData.NewsCategory) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [BrokerData.NewsCategory]
  public static var allCases: [BrokerData.NewsCategory] {
    get
  }
}
@objc final public class MoneyFormatter : Foundation.MeasurementFormatter {
  public static let short: BrokerData.MoneyFormatter
  public static let medium: BrokerData.MoneyFormatter
  final public var withoutSpace: Swift.Bool
  public init(numberFormatter: Foundation.NumberFormatter = NumberFormatter.friendly, unitStyle: Foundation.Formatter.UnitStyle = .short)
  final public func string(from price: BrokerData.Price) -> Swift.String
  @objc override final public func string(from measurement: Foundation.Measurement<Foundation.Unit>) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
extension URL {
  public struct Broker {
    public static let shortDobsProd: Foundation.URL
    public static let shortDobsText: Foundation.URL
    public static var prod: Foundation.URL {
      get
    }
    public static var test: Foundation.URL {
      get
    }
    public static var test2: Foundation.URL {
      get
    }
    public static var websocketQuotes: Foundation.URL {
      get
    }
  }
}
public struct WithdrawOrder {
  public let requestNum: Swift.Int
  public let recipient: Swift.String
  public let date: Foundation.Date
  public let fio: Swift.String
  public let agreementNo: Swift.String
  public let agreementDate: Foundation.Date
  public let account: Swift.String
  public let tradeFloor: Swift.String
  public let amount: Swift.String?
  public let bankAccount: BrokerData.BankAccount
}
extension WithdrawOrder : Swift.Hashable {
  public static func == (lhs: BrokerData.WithdrawOrder, rhs: BrokerData.WithdrawOrder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Encodable {
  public func store(key: Swift.String, userDefaults: Foundation.UserDefaults = .standard)
}
extension Decodable {
  public static func restore(key: Swift.String, userDefaults: Foundation.UserDefaults = .standard) -> Self?
  public static func restore(key: Swift.String, userDefaults: Foundation.UserDefaults = .standard) throws -> Self
}
public class FinQuote : Swift.Equatable {
  final public let instrument: BrokerData.FinInstrument
  final public let userProperties: BrokerData.FinUserProperties
  public var prices: BrokerData.FinPrices
  public var tradeSessionPriceChange: BrokerData.Change
  final public let yield: BrokerData.FinYield
  public var time: Foundation.Date
  public init(instrument: BrokerData.FinInstrument, userProperties: BrokerData.FinUserProperties = .blank, prices: BrokerData.FinPrices = .zero, tradeSessionPriceChange: BrokerData.Change = .zero, yield: BrokerData.FinYield = .zero, time: Foundation.Date? = nil)
  public static let unknown: BrokerData.FinQuote
  public func update(by quote: BrokerData.FinQuote)
  @objc deinit
}
public func == (lhs: BrokerData.FinQuote, rhs: BrokerData.FinQuote) -> Swift.Bool
extension FinInstrument {
  final public var realtimeQuotes: RxSwift.Observable<BrokerData.FinQuote> {
    get
  }
  final public var logo: BrokerData.ImageResource? {
    get
  }
  final public var fullIdentifiable: RxSwift.Single<BrokerData.FinInstrument> {
    get
  }
  final public var isSmallLot: Swift.Bool {
    get
  }
  final public var smallLot: BrokerData.SmallLot? {
    get
  }
}
public struct News {
  public let newsId: BrokerData.NewsId
  public let title: Swift.String
  public let publishedAt: Foundation.Date
  public let hasVideo: Swift.Bool
  public let source: Swift.String
  public let image: BrokerData.ImageResource?
  public let announce: Swift.String
  public let instrument: BrokerData.FinInstrument?
}
public struct NewsDetails {
  public let news: BrokerData.News
  public let body: Swift.String
  public let relatedNews: [BrokerData.News]
  public let userInfo: BrokerData.FinUserProperties?
  public let quote: BrokerData.FinQuote?
}
extension News : Swift.Hashable {
  public static func == (lhs: BrokerData.News, rhs: BrokerData.News) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc final public class BigNumberFormatter : Foundation.NumberFormatter {
  @objc override dynamic public init()
  @objc override final public func string(from number: Foundation.NSNumber) -> Swift.String?
  @objc deinit
}
extension ETTradingService {
  public class AccountListItemResponse : Swift.Decodable {
    final public let accountId: Swift.Int
    final public let name: Swift.String
    final public let displayName: Swift.String
    final public let type: Swift.String
    final public let isTradingAccount: Swift.Bool
    final public let client: BrokerData.ETTradingService.AccountListItemResponse.Client
    final public let clientCode: Swift.String?
    final public let tradeAccountMapId: Swift.Int?
    final public let freeCashInstrumentCurrency: Swift.Double
    final public let freeCash: Swift.Double
    final public let freeMoney: BrokerData.ETTradingService.AccountListItemResponse.FreeMoney
    final public let marketValue: Swift.Double
    public struct Client : Swift.Decodable {
      public let agreement: Swift.String
      public let agreementId: Swift.String
      public let name: Swift.String
      public let clientId: Swift.Int
      public init(from decoder: Swift.Decoder) throws
    }
    public struct FreeMoney : Swift.Decodable {
      public let rur: Swift.Double
      public let eur: Swift.Double
      public let usd: Swift.Double
      public init(from decoder: Swift.Decoder) throws
    }
    @objc deinit
    required public init(from decoder: Swift.Decoder) throws
  }
}
final public class ETPasswordServiceConfigurator : BrokerData.ETServiceConfigurator {
  override public init(baseUrl: Foundation.URL, plugins: [APICore.Plugin] = super, appVersion: Swift.String = super, appBuild: Swift.String = super, policies: [Swift.String : Alamofire.ServerTrustPolicy]? = super)
  @objc deinit
}
public class MLServiceConfigurator : APICore.DefaultAPIServiceConfigurator {
  override public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  override public init(baseUrl: Foundation.URL)
  override public init(baseUrl: Foundation.URL, sessionManager: APICore.SessionManager = super, bodyEncoding: @escaping APICore.MethodBodyEncoding = super, plugins: [APICore.Plugin] = super, headers: [Swift.String : Swift.String]? = super, requestsErrorBehavior: APICore.RequestErrorBehavior? = super)
  @objc deinit
}
extension ETUserService {
  public struct InterviewState : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Preferences : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SettingsReponse : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class InstrumentLogoProvider {
  public static let shared: BrokerData.InstrumentLogoProvider
  public typealias Ticker = Swift.String
  final public func getImage(ticker: BrokerData.InstrumentLogoProvider.Ticker, completion: @escaping BCSSwiftTools.ImageProviderCompletion)
  final public func restoreCache()
  @objc deinit
}
extension ETDepositService {
  public struct StartOrderResponse : Swift.Decodable {
    public let contributionByMonth: Swift.Double
    public let contributionComission: Swift.Double
    public let contributionLimit: Swift.Double
    public let contributionRest: Swift.Double
    public let uCSLimit: Swift.Double
    public let adv: BrokerData.ETDepositService.StartOrderResponse.Adv?
    public struct Adv : Swift.Decodable {
      public let dateTo: Foundation.Date?
      public let contributionComission: Swift.Double?
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct RegisterOrderResponse : Swift.Decodable {
    public let paycode: Swift.String
    public let redirectUrl: Swift.String
    public let session: Swift.String
    public let number: Swift.Int
    public init(from decoder: Swift.Decoder) throws
  }
  public struct GetOrderItemResponse : Swift.Decodable {
    public let number: Swift.Int
    public let accountPay: Swift.String
    public let cardMask: Swift.String
    public let amountPay: Swift.Double
    public let uCSstatus: Swift.String
    public let agreement: Swift.String
    public let status: Swift.Int
    public let date: Foundation.Date
    public let tradeFloor: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class DDSuggestService : APICore.APIService<BrokerData.DDSuggestService.Methods, BrokerData.DDServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case address(query: Swift.String, count: Swift.Int)
    case fms(query: Swift.String)
  }
  required public init()
  @objc deinit
}
extension DDSuggestService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension DDSuggestService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case address
    case fms
    public typealias RawValue = Swift.String
    public typealias AllCases = [BrokerData.DDSuggestService.Methods.MockKey]
    public static var allCases: [BrokerData.DDSuggestService.Methods.MockKey] {
      get
    }
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.DDSuggestService.Methods.MockKey? {
    get
  }
}
extension DDSuggestService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
final public class NewStopLimitOrder : BrokerData.NewLimitOrder {
  final public var activationPrice: BrokerData.ActivationPrice {
    get
    set
  }
  override final public var isValid: Swift.Bool {
    get
  }
  override final public var isCorrectPrice: Swift.Bool {
    get
  }
  final public var pricesDifMoreThen10percents: Swift.Bool? {
    get
  }
  override public init(_ tradingInfo: BrokerData.NewOrder.TradingInfo, draft: BrokerData.NewOrder.Draft? = super, price: Swift.Double? = super)
  @objc deinit
}
public typealias ServerTrustPolicyDict = [Swift.String : Alamofire.ServerTrustPolicy]
public struct ServerTrustPolicies {
  public static var policy: BrokerData.ServerTrustPolicyDict
}
extension BroData.IIA {
  public struct New {
    public typealias AgreementId = Swift.String
    public typealias AgreementDocument = Foundation.Data
    public enum RequestStatus {
      case succeed(APICore.MethodRedirect)
      case pending
      case error(BrokerData.BroData.IIA.New.RequestStatusError)
      public init(resp: BrokerData.MBIISService.StatusResponse, redirect: APICore.MethodRedirect?)
    }
    public enum RequestStatusError {
      case alreadyHaveIIA
      case unknown(Swift.String?)
    }
    public enum OpeningStatus {
      case succeed
      case pending
      case error(BrokerData.BroData.IIA.New.OpeningStatusError)
      public init(resp: BrokerData.MBIISService.StatusResponse)
    }
    public enum OpeningStatusError {
      case needPassport
      case unknown(Swift.String?)
    }
  }
}
extension BroData.IIA.New {
  public static func newRequest() -> RxSwift.Single<(BrokerData.BroData.IIA.New.AgreementId, APICore.MethodRedirect)>
  public static func requestStatus(methodLocation path: APICore.MethodLocation) -> RxSwift.Single<BrokerData.BroData.IIA.New.RequestStatus>
  public static func document(methodLocation path: APICore.MethodLocation) -> RxSwift.Single<BrokerData.BroData.IIA.New.AgreementDocument?>
  public static func requestSmsSignCode(for agreementId: BrokerData.BroData.IIA.New.AgreementId) -> RxSwift.Single<Swift.Void>
  public static func resendSmsSignCode(agreementId: BrokerData.BroData.IIA.New.AgreementId) -> RxSwift.Single<Swift.Void>
  public static func signDocument(code: Swift.String, agreementId: BrokerData.BroData.IIA.New.AgreementId) -> RxSwift.Single<APICore.MethodRedirect>
  public static func accountOpeningStatus(methodLocation path: APICore.MethodLocation) -> RxSwift.Single<BrokerData.BroData.IIA.New.OpeningStatus>
}
public struct OrderBookItem {
  public enum Kind {
    case bid, ask
    public static func == (a: BrokerData.OrderBookItem.Kind, b: BrokerData.OrderBookItem.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let price: Swift.Double
  public let volume: Swift.Double
  public let kind: BrokerData.OrderBookItem.Kind
  public let volumePercents: Swift.Double
}
public struct OrderBook {
  public let instrument: BrokerData.FinInstrument
  public let snapshotDate: Foundation.Date
  public let items: [BrokerData.OrderBookItem]
  public let fullVolume: Swift.Double
  public let bidVolume: Swift.Double
  public let askVolume: Swift.Double
}
extension ETDataService {
  public struct TradeFloorItemResponse : Swift.Decodable {
    public let tradeFloorId: Swift.Int
    public let name: Swift.String
    public let freeCash: Swift.Double
    public let canWithdrawal: Swift.Bool
    public init(from decoder: Swift.Decoder) throws
  }
  public struct BankItemResponse : Swift.Decodable {
    public let bankId: Swift.Int
    public let name: Swift.String
    public let fullName: Swift.String
    public let extCode: Swift.String
    public let bIK: Swift.String?
    public let country: Swift.String
    public let city: Swift.String
    public let liveStatus: Swift.Int
    public let correspondentAccount: Swift.String?
    public let currencyRestrict: Swift.Int
    public init(from decoder: Swift.Decoder) throws
  }
}
public struct Forecast {
  public let recomendation: Swift.String
  public let pricePredictionPercents: Foundation.NSDecimalNumber
  public let pricePrediction: Foundation.NSDecimalNumber
}
final public class ETTradingService : APICore.APIService<BrokerData.ETTradingService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public typealias PIN = Swift.String
  public typealias OrderId = Swift.Int
  public typealias OrderRequestId = Swift.Int
  public typealias UserRequestId = Swift.String
  public enum Methods {
    case accountList(BrokerData.InstrumentId?)
    case instrument(BrokerData.InstrumentId, ticker: Swift.String?, classCode: Swift.String?)
    case orderSave(BrokerData.ETTradingService.Methods.SaveRequestParams)
    case orderSaveByPIN(BrokerData.ETTradingService.Methods.SaveRequestParams, BrokerData.ETTradingService.PIN)
    case orderConfirm(BrokerData.ETTradingService.OrderRequestId, code: Swift.String, agreement: Swift.String?)
    case orderGetNewId
    case order(BrokerData.ETTradingService.OrderId)
    case orderCheckPIN(BrokerData.ETTradingService.PIN)
    case sendNewConfirmOrderRequestCode(BrokerData.ETTradingService.OrderRequestId)
    case orderCancel(BrokerData.ETTradingService.OrderId)
    case orderConfirmTypeSMS
    case orderConfirmTypePIN(BrokerData.ETTradingService.PIN)
    case orderConfirmTypeConfirm(BrokerData.ETTradingService.UserRequestId, code: Swift.String)
  }
  required public init()
  @objc deinit
}
extension ETTradingService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETTradingService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case tradingAccountList
    case tradingInstrument
    case tradingOrderSave
    case tradingOrderSaveByPIN
    case tradingOrderConfirm
    case tradingOrderGetNewId
    case tradingOrder
    case tradingOrderCheckPIN
    case tradingSendNewConfirmOrderRequestCode
    case tradingOrderCancel
    case tradingOrderConfirmTypeSMS
    case tradingOrderConfirmTypePIN
    case tradingOrderConfirmTypeConfirm
    public typealias AllCases = [BrokerData.ETTradingService.Methods.MockKey]
    public static var allCases: [BrokerData.ETTradingService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETTradingService.Methods.MockKey? {
    get
  }
}
extension ETTradingService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
extension NumberFormatter {
  public var copy: Foundation.NumberFormatter {
    get
  }
  public static let friendly: Foundation.NumberFormatter
  public static let friendlyWithSign: Foundation.NumberFormatter
  public static let percents: Foundation.NumberFormatter
  public static let percentsWithSign: Foundation.NumberFormatter
  public static let bigNumber: Foundation.NumberFormatter
}
final public class ETNewsService : APICore.APIService<BrokerData.ETNewsService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case list(BrokerData.ETNewsService.Methods.ListParams)
    case single(BrokerData.NewsId)
  }
  required public init()
  @objc deinit
}
extension ETNewsService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETNewsService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case list
    case single
    public typealias RawValue = Swift.String
    public typealias AllCases = [BrokerData.ETNewsService.Methods.MockKey]
    public static var allCases: [BrokerData.ETNewsService.Methods.MockKey] {
      get
    }
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETNewsService.Methods.MockKey? {
    get
  }
}
public struct Agreement : Swift.Codable {
  public let identifier: Swift.String
  public let header: Swift.String
  public let number: Swift.String
  public let client: BrokerData.Client
  public static let unknown: BrokerData.Agreement
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct CantCreateBrokerDataModel : Swift.Error {
  public let responseModel: Swift.AnyObject?
  public let localizedDescription: Swift.String
}
public struct BCSOffice {
  public let id: Swift.String
  public let name: Swift.String
  public let address: Swift.String
  public var phone: Swift.String
  public var coordinates: CoreLocation.CLLocationCoordinate2D
  public var hoursOfService: Swift.String
  public var daysOfService: Swift.String
}
extension BroData.Account {
  public struct Deposit {
    public typealias Number = BrokerData.ETDepositService.Methods.Number
    public typealias PaymentComissionParams = BrokerData.Best2PayService.Methods.PaymentComissionParams
    public typealias AcceptPaymentParams = BrokerData.Best2PayService.Methods.AcceptPaymentParams
    public typealias PaymentPageParams = BrokerData.Best2PayService.Methods.PaymentPageParams
    public typealias PaymentStatusParams = BrokerData.Best2PayService.Methods.PaymentStatusParams
    public typealias GetQRCodeParams = BrokerData.BRSService.Methods.GetQRCodeParams
    public struct NewDepositOrder {
      public let amount: Swift.Double
      public let account: BrokerData.Account
      public let tradeFloor: BrokerData.TradeFloor
      public init(amount: Swift.Double, account: BrokerData.Account, tradeFloor: BrokerData.TradeFloor)
    }
  }
}
extension BroData.Account.Deposit {
  public static func marketingCampaign(by account: BrokerData.Account) -> RxSwift.Single<BrokerData.MarketingCampaign?>
  public static func depostiDetails(currency: BrokerData.Currency) -> RxSwift.Single<BrokerData.DepositDetails>
  public static func limitInfo(by account: BrokerData.Account) -> RxSwift.Single<BrokerData.DepositLimitInfo>
  public static func registerNewDepositOrder(params: BrokerData.BroData.Account.Deposit.NewDepositOrder) -> RxSwift.Single<BrokerData.DepositOrderRegistrationInfo>
  public static func depositOrders(by number: BrokerData.BroData.Account.Deposit.Number) -> RxSwift.Single<[BrokerData.DepositOrder]>
  public static func paymentDraft(by params: BrokerData.BroData.Account.Deposit.PaymentComissionParams) -> RxSwift.Single<BrokerData.Best2PayPaymentComission>
  public static func acceptPayment(by params: BrokerData.BroData.Account.Deposit.AcceptPaymentParams) -> RxSwift.Single<BrokerData.Best2PayPayment>
  public static func paymentPage(by params: BrokerData.BroData.Account.Deposit.PaymentPageParams) -> RxSwift.Single<BrokerData.PaymentPage>
  public static func statusPayment(by params: BrokerData.BroData.Account.Deposit.PaymentStatusParams) -> RxSwift.Single<BrokerData.Best2PayPaymentStatus>
  public static func getQRCode(by params: BrokerData.BroData.Account.Deposit.GetQRCodeParams) -> RxSwift.Single<BrokerData.QRCodePayment>
}
extension ETGeoService.Methods {
  public struct ListParams {
    public let lat: Swift.Double
    public let lng: Swift.Double
    public let offset: Swift.Int
    public let pageSize: Swift.Int
    public let search: Swift.String?
    public let range: Swift.Double?
    public let types: Swift.String
    public var asDictionary: [Swift.String : Any] {
      get
    }
    public init(lat: Swift.Double, lng: Swift.Double, offset: Swift.Int, pageSize: Swift.Int, search: Swift.String?, range: Swift.Double?, types: Swift.String)
  }
}
final public class ETGeoService : APICore.APIService<BrokerData.ETGeoService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case list(BrokerData.ETGeoService.Methods.ListParams)
    case city
  }
  required public init()
  @objc deinit
}
extension ETGeoService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETGeoService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case list
    case city
    public typealias AllCases = [BrokerData.ETGeoService.Methods.MockKey]
    public static var allCases: [BrokerData.ETGeoService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETGeoService.Methods.MockKey? {
    get
  }
}
extension ETGeoService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
extension ETPortfelService.Methods {
  public struct PLByInstrumentRequestParams {
    public init(dateFrom: Foundation.Date, dateTo: Foundation.Date, currency: BrokerData.Currency = .RUB, accountsIds: [Swift.Int] = [], instrumentId: BrokerData.InstrumentId? = nil)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
  public struct TableOrderRequestParams {
    public init(dateFrom: Foundation.Date, dateTo: Foundation.Date, accountsIds: [Swift.Int] = [], instrumentId: BrokerData.InstrumentId? = nil)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
  public struct TableTradeRequestParams {
    public init(offset: Swift.Int, pageSize: Swift.Int, accountsIds: [Swift.Int] = [], instrumentId: BrokerData.InstrumentId? = nil)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
  public typealias TableTradeNoPagingRequestParams = BrokerData.ETPortfelService.Methods.TableOrderRequestParams
  public struct NonTradeOperationRequestParams {
    public init(offset: Swift.Int, pageSize: Swift.Int, dateFrom: Foundation.Date, dateTo: Foundation.Date, accountsIds: [Swift.Int] = [])
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
}
extension BroData {
  public struct Strategy {
    public typealias BindParams = BrokerData.FinTargetService.Methods.BindParams
    public typealias UnbindParams = BrokerData.FinTargetService.Methods.UnbindParams
    public typealias ConfirmBindParams = BrokerData.FinTargetService.Methods.ConfirmBindParams
    public typealias ConfirmUnbindParams = BrokerData.FinTargetService.Methods.ConfirmUnbindParams
    public enum Error : Swift.Error {
      case error(code: Swift.Int, message: Swift.String?)
      case needRiskProfile
    }
  }
}
extension BroData.Strategy {
  public static func list() -> RxSwift.Single<[BrokerData.Strategy]>
  public static func details(id: BrokerData.StrategyId) -> RxSwift.Single<BrokerData.Strategy>
  public static func bind(by params: BrokerData.BroData.Strategy.BindParams) -> RxSwift.Single<Swift.String>
  public static func unbind(by params: BrokerData.BroData.Strategy.UnbindParams) -> RxSwift.Single<Swift.String>
  public static func confirmBind(by params: BrokerData.BroData.Strategy.ConfirmBindParams) -> RxSwift.Single<Swift.Void>
  public static func confirmUnbind(by params: BrokerData.BroData.Strategy.ConfirmUnbindParams) -> RxSwift.Single<Swift.Void>
  public static func clientProfile() -> RxSwift.Single<BrokerData.ClientInvestProfile>
}
public typealias InvestIdeaAuthor = BrokerData.InvestIdea.Author
public typealias Idea = BrokerData.InvestIdea
extension BroData {
  public enum Notification {
    public static var output: RxSwift.Observable<BrokerData.BroData.Notification> {
      get
    }
    case changeIdeaFavorite(isFavorite: Swift.Bool, idea: BrokerData.Idea)
    case changeIdeaAuthorFavorite(isFavorite: Swift.Bool, author: BrokerData.InvestIdeaAuthor)
    case changeInstrumentIsFavorite(isFavorite: Swift.Bool, instrument: BrokerData.FinInstrument)
    case changedOrderConfirmType(BrokerData.OrderConfirmType)
  }
}
extension ETAuthService {
  public enum SignUpResponse : Swift.Equatable {
    case ok
    case errorStatus2
    case errorStatus3
    case errorStatus4
    case errorStatus5
    case errorStatus6
    case errorStatus7
    case errorStatus8
    case errorStatus9
    case errorStatus10
    case errorStatus11
    case errorStatus12
    case unknownFailed(Swift.Int)
  }
}
public func == (lhs: BrokerData.ETAuthService.SignUpResponse, rhs: BrokerData.ETAuthService.SignUpResponse) -> Swift.Bool
extension ETAuthService.SignUpResponse : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension URL {
  public struct SlackChanel {
    public static let logs: Foundation.URL
    public static let clientFeedback: Foundation.URL
  }
}
final public class SlackMessenger {
  public static let shared: BrokerData.SlackMessenger
  final public func send(text: Swift.String, to url: Foundation.URL, completion: @escaping () -> Swift.Void = {})
  @objc deinit
}
public typealias PriceUnit = BrokerData.MoneyUnit
public typealias Currency = BrokerData.MoneyUnit
public typealias Price = Foundation.Measurement<BrokerData.MoneyUnit>
public typealias Money = Foundation.Measurement<BrokerData.MoneyUnit>
@objc final public class MoneyUnit : Foundation.Dimension {
  final public let code: Swift.String
  final public let name: Swift.String
  final public let textCase: BCSSwiftTools.TextCase?
  public init(code: Swift.String, name: Swift.String = "", symbol: Swift.String, textCase: BCSSwiftTools.TextCase? = nil)
  public static func by(code: Swift.String) -> BrokerData.MoneyUnit
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  public static let baseUnit: BrokerData.MoneyUnit
  public static let RUB: BrokerData.MoneyUnit
  public static let USD: BrokerData.MoneyUnit
  public static let EUR: BrokerData.MoneyUnit
  public static let GBP: BrokerData.MoneyUnit
  public static let CNY: BrokerData.MoneyUnit
  public static let CHF: BrokerData.MoneyUnit
  public static let pt: BrokerData.MoneyUnit
  public static let percents: BrokerData.MoneyUnit
  public static let unknown: BrokerData.MoneyUnit
  @objc override dynamic public init(symbol: Swift.String, converter: Foundation.UnitConverter)
  @objc deinit
}
extension String {
  public var currency: BrokerData.Currency {
    get
  }
}
extension Measurement where UnitType == BrokerData.MoneyUnit {
  public init(_ value: Foundation.NSDecimalNumber, unit: UnitType)
  public static let unknown: Foundation.Measurement<BrokerData.MoneyUnit>
  public static func rub(_ value: Swift.Double) -> Foundation.Measurement<BrokerData.MoneyUnit>
  public static func usd(_ value: Swift.Double) -> Foundation.Measurement<BrokerData.MoneyUnit>
  public static func eur(_ value: Swift.Double) -> Foundation.Measurement<BrokerData.MoneyUnit>
  public static func percents(_ value: Swift.Double) -> Foundation.Measurement<BrokerData.MoneyUnit>
  public static func pt(_ value: Swift.Double) -> Foundation.Measurement<BrokerData.MoneyUnit>
}
extension TextCase {
  public static var ruble: BCSSwiftTools.TextCase {
    get
  }
  public static var dollar: BCSSwiftTools.TextCase {
    get
  }
  public static var euro: BCSSwiftTools.TextCase {
    get
  }
}
extension MoneyUnit : Swift.Codable {
  convenience public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
}
extension MoneyUnit {
  public static func orderCurrency(byInstrumentPriceUnit currency: BrokerData.MoneyUnit) -> BrokerData.Currency
}
final public class NewMarketOrder : BrokerData.NewOrder {
  override public init(_ tradingInfo: BrokerData.NewOrder.TradingInfo, draft: BrokerData.NewOrder.Draft? = super)
  @objc deinit
}
final public class FinTargetService : APICore.APIService<BrokerData.FinTargetService.Methods, BrokerData.FinTargetConfigurator> {
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case strategies
    case strategy(BrokerData.StrategyId)
    case bind(BrokerData.FinTargetService.Methods.BindParams)
    case unbind(BrokerData.FinTargetService.Methods.UnbindParams)
    case confirmBind(BrokerData.FinTargetService.Methods.ConfirmBindParams)
    case confirmUnbind(BrokerData.FinTargetService.Methods.ConfirmUnbindParams)
    case clientProfile
  }
  required public init()
  @objc deinit
}
extension FinTargetService.Methods : Moya.AccessTokenAuthorizable {
  public var authorizationType: Moya.AuthorizationType {
    get
  }
}
extension FinTargetService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension BroData {
  public struct InvestIdea {
  }
}
extension BroData.InvestIdea {
  public struct Author {
    public static var authorCacheRule: RxObservableCache.CacheRule
  }
  public struct ListFilter {
    public let category: BrokerData.InvestIdeasCategory
    public let insturmentId: BrokerData.InstrumentId?
    public let authorId: BrokerData.AuthorId?
    public let paging: BrokerData.Paging
    public init(category: BrokerData.InvestIdeasCategory = .all, insturment: BrokerData.InstrumentId? = nil, authorId: BrokerData.AuthorId? = nil, paging: BrokerData.Paging = .firsts(100))
    public static let all: BrokerData.BroData.InvestIdea.ListFilter
  }
  public static func list(filter: BrokerData.BroData.InvestIdea.ListFilter) -> RxSwift.Single<[BrokerData.InvestIdea]>
  public static func details(for id: BrokerData.InvestIdeaId) -> RxSwift.Single<BrokerData.InvestIdeaDetails>
  public static func set(isFavorite: Swift.Bool, for idea: BrokerData.InvestIdea) -> RxSwift.Single<Swift.Void>
}
extension BroData.InvestIdea.Author {
  public static func list(cacheRule: RxObservableCache.CacheRule = .writeOnly) -> RxSwift.Single<[BrokerData.InvestIdea.Author]>
  public static func set(isFavorite: Swift.Bool, for author: BrokerData.InvestIdea.Author) -> RxSwift.Single<Swift.Void>
}
extension JSONDecoder {
  public static let etJsonDecoder: Foundation.JSONDecoder
  public static let finTargetJsonDecoder: Foundation.JSONDecoder
}
extension JSONDecoder.KeyDecodingStrategy {
  public static let PascalToCamel: ([Swift.CodingKey]) -> Swift.CodingKey
  public static let CamelToPascal: ([Swift.CodingKey]) -> Swift.CodingKey
}
public typealias Identifier = Swift.Int
public typealias ClassCode = Swift.String
public typealias FinPrices = BrokerData.FinInstrument.Prices
public typealias FinProperties = BrokerData.FinInstrument.Properties
public typealias FinUserProperties = BrokerData.FinInstrument.UserProperties
public typealias FinAssetProperties = BrokerData.FinInstrument.AssetProperties
public typealias FinInfo = BrokerData.FinInstrument.Info
public func == (lhs: BrokerData.FinInstrument, rhs: BrokerData.FinInstrument) -> Swift.Bool
extension FinInstrument : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class FinInstrument : Swift.Equatable, Swift.CustomStringConvertible, Swift.Codable {
  final public let identifier: BrokerData.Identifier
  final public let tiker: Swift.String
  final public let name: Swift.String
  final public let pips: BrokerData.Pips
  final public let priceUnit: BrokerData.PriceUnit
  final public let classCode: BrokerData.ClassCode
  final public let kind: BrokerData.FinInstrument.Kind
  final public let associatedCurrency: BrokerData.Currency?
  public init(identifier: BrokerData.Identifier, tiker: Swift.String = .unknown, name: Swift.String = .unknown, pips: BrokerData.Pips = .default, priceUnit: BrokerData.PriceUnit = .unknown, classCode: Swift.String = .unknown, kind: BrokerData.FinInstrument.Kind = .unknown, associatedCurrency: BrokerData.Currency? = nil)
  convenience public init(instrument: BrokerData.FinInstrument)
  convenience public init(instrument: BrokerData.FinInstrument, kind: BrokerData.FinInstrument.Kind)
  convenience public init(instrument: BrokerData.FinInstrument, pips: BrokerData.Pips, priceUnit: BrokerData.PriceUnit)
  public static let unknown: BrokerData.FinInstrument
  public static let unknownID: Swift.Int
  final public var isUnknownID: Swift.Bool {
    get
  }
  @objc deinit
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension FinInstrument {
  public struct Prices {
    public let opening: Swift.Double
    public let closing: Swift.Double
    public let last: Swift.Double
    public let high: Swift.Double
    public let low: Swift.Double
    public let ask: Swift.Double
    public let bid: Swift.Double
    public let date: Foundation.Date
    public static var zero: BrokerData.FinInstrument.Prices
    public init(opening: Swift.Double? = nil, closing: Swift.Double? = nil, last: Swift.Double? = nil, high: Swift.Double? = nil, low: Swift.Double? = nil, ask: Swift.Double? = nil, bid: Swift.Double? = nil, date: Foundation.Date? = nil)
  }
}
extension FinInstrument {
  public struct Properties {
    public enum TradeState {
      case marketOpen
      case marketClosed
      public static func == (a: BrokerData.FinInstrument.Properties.TradeState, b: BrokerData.FinInstrument.Properties.TradeState) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public let state: Swift.Int
    public let tradeState: BrokerData.FinInstrument.Properties.TradeState
    public let lotSize: Swift.Int
    public let priceMultiplier: Swift.Double
    public let margin: Swift.Double
    public let volume: Swift.Double
    public let daysToMaturity: Swift.Int
    public let accruedInterest: Swift.Double
    public let orderCurrency: BrokerData.Currency
    public let availableOrderTypes: [BrokerData.OrderType]
    public let notional: Swift.Double
    public init(state: Swift.Int, lotSize: Swift.Int, priceMultiplier: Swift.Double, margin: Swift.Double, volume: Swift.Double, daysToMaturity: Swift.Int, ai: Swift.Double, notional: Swift.Double, orderCurrency: BrokerData.Currency, availableOrderTypes: [BrokerData.OrderType])
    public static let empty: BrokerData.FinInstrument.Properties
  }
}
extension FinInstrument {
  public class UserProperties {
    final public let canOrder: Swift.Int
    final public let hasAlert: Swift.Bool
    final public let hasPosition: Swift.Bool
    final public let hasOrder: Swift.Bool
    public var favorite: Swift.Bool
    final public let investigated: Swift.Bool
    public var canTrade: Swift.Bool {
      get
    }
    public static let blank: BrokerData.FinInstrument.UserProperties
    @objc deinit
  }
}
extension FinInstrument {
  public class AssetProperties {
    final public let revaluation: BrokerData.Money
    final public let revaluationPercents: BrokerData.Money
    final public let balancePrice: BrokerData.Price
    final public let balanceCost: BrokerData.Money
    final public let amount: Swift.Double
    final public let marketValue: BrokerData.Money
    final public let share: Swift.Double
    public static let blank: BrokerData.FinInstrument.AssetProperties
    @objc deinit
  }
}
extension FinInstrument {
  public struct Info {
    public let short: Swift.String
    public let full: Swift.String
    public init(short: Swift.String? = nil, full: Swift.String? = nil)
    public var description: Swift.String {
      get
    }
  }
  final public var debugShort: Swift.String {
    get
  }
}
extension TextCase {
  public static var days: BCSSwiftTools.TextCase {
    get
  }
  public static var instruments: BCSSwiftTools.TextCase {
    get
  }
}
public enum SmallLot : Swift.CaseIterable {
  case usd
  case eur
  public static func == (a: BrokerData.SmallLot, b: BrokerData.SmallLot) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [BrokerData.SmallLot]
  public static var allCases: [BrokerData.SmallLot] {
    get
  }
}
public struct DepositOrderRegistrationInfo {
  public let paycode: Swift.String
  public let redirectUrl: Swift.String
  public let session: Swift.String
  public let number: Swift.Int
}
extension ETPortfelService {
  public struct TableTradeResponse : Swift.Decodable {
    public let externalId: Swift.String
    public let tradeId: Swift.Int
    public let status: Swift.Int
    public let amount: Swift.Double
    public let payment: Swift.Double
    public let price: Swift.Double
    public let client: Swift.String
    public let bS: Swift.Int
    public let date: Foundation.Date
    public let instrument: BrokerData.ETInstrument
    public let account: Swift.String?
    public let accountId: BrokerData.AccountId?
    public init(from decoder: Swift.Decoder) throws
  }
}
extension ETNewsService.Methods {
  public struct ListParams {
    public init(category: Swift.String, type: Swift.String? = nil, pageSize: Swift.Int, ts: Any, offset: Swift.Int, tag: Swift.String)
  }
}
extension MBIISService {
  public enum Status : Swift.String, Swift.Decodable {
    case succeed
    case pending
    case failed
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public struct CreateAgreementResponse : Swift.Decodable {
    public let agreementId: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct StatusResponse : Swift.Decodable {
    public let status: BrokerData.MBIISService.Status
    public let errorMessage: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct GetAgreementResponse : Swift.Decodable {
    public let base64agreement: Swift.String
    public init(from decoder: Swift.Decoder) throws
    public var pdf: Foundation.Data? {
      get
    }
  }
}
extension NumberFormatter {
  public enum Config {
    case fracDigits(min: Swift.Int?, max: Swift.Int?)
    case minMaxFracDigits(Swift.Int)
    case showUnsignificantZero
    case ignoreMaxDigits
    case showSign
    case hideSign
    case percentStyle
  }
  @discardableResult
  public func configurate(config: Foundation.NumberFormatter.Config...) -> Foundation.NumberFormatter
  public static func formatter(where config: Foundation.NumberFormatter.Config...) -> Foundation.NumberFormatter
  @discardableResult
  public static func configurate(formatter: Foundation.NumberFormatter, configs: [Foundation.NumberFormatter.Config]) -> Foundation.NumberFormatter
}
public typealias BrokerAccount = BrokerData.Account
public typealias UserSessionId = Swift.String
public typealias UserSession = BrokerData.BroData.Session
extension BroData {
  final public class Session {
    public static var current: BrokerData.BroData.Session? {
      get
      }
    @discardableResult
    final public func refreshUser() -> RxSwift.Single<Swift.Void>
    public static func demoSession(user: BrokerData.BroData.User) -> BrokerData.BroData.Session
    public static var lastActiveSessionId: BrokerData.UserSessionId? {
      get
    }
    public static var isDemoSession: Swift.Bool {
      get
    }
    final public var isClientSession: Swift.Bool {
      get
    }
    public static func invalidateSession()
    public static func set(current: BrokerData.BroData.Session)
    final public let id: BrokerData.UserSessionId
    final public var user: BrokerData.BroData.User {
      get
      }
    public init(id: BrokerData.UserSessionId, user: BrokerData.BroData.User)
    @objc deinit
  }
}
extension BroData.Session {
  public static func newSession() -> RxSwift.Single<BrokerData.BroData.Session>
  public enum AuthType {
    case credentials(BrokerData.BroData.Security.AuthCredential)
    case refresh(Swift.String)
    case demo
  }
  public enum Environment {
    case prod
    case test
    public static func == (a: BrokerData.BroData.Session.Environment, b: BrokerData.BroData.Session.Environment) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static func setup(auth: BrokerData.BroData.Session.AuthType, environment: BrokerData.BroData.Session.Environment, enbaleLogs: Swift.Bool, delegate: APICore.APIServiceConfiguratorDelegate) -> RxSwift.Single<Swift.Void>
}
extension BroData.Session {
  final public func setAsActiveSession()
}
public struct ETImage : Swift.Decodable {
  public let small: Swift.String?
  public let medium: Swift.String?
  public let big: Swift.String?
  public var mediumUrl: Foundation.URL? {
    get
  }
  public var smallUrl: Foundation.URL? {
    get
  }
  public var bigUrl: Foundation.URL? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct InvestIdea {
  public let identifier: BrokerData.IdeaId
  public let publishedAt: Foundation.Date
  public let instrument: BrokerData.FinInstrument
  public let tradeType: BrokerData.TradingType
  public let openDate: Foundation.Date
  public let closeDate: Foundation.Date
  public let title: Swift.String
  public let announce: Swift.String
  public var author: BrokerData.InvestIdea.Author {
    get
    }
  public let userProperies: BrokerData.InvestIdea.UserProperties
  public let profit: BrokerData.InvestIdea.Profit
  public let state: BrokerData.InvestIdea.State
  public let finished: BrokerData.InvestIdea.Finished?
  public let daysToEnd: Swift.Int
}
extension InvestIdea {
  public var daysDuration: Swift.Int {
    get
  }
}
extension InvestIdea {
  public struct Finished {
    public enum Kind {
      case stopLoss
      case target
      case unknown
      public static func == (a: BrokerData.InvestIdea.Finished.Kind, b: BrokerData.InvestIdea.Finished.Kind) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public let date: Foundation.Date
    public let profit: Swift.Double
    public let kind: BrokerData.InvestIdea.Finished.Kind
    public let price: Swift.Double
  }
  public enum State {
    case finished
    case active
    case unknown
    public static func == (a: BrokerData.InvestIdea.State, b: BrokerData.InvestIdea.State) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct Profit {
    public let expected: Swift.Double
    public let actual: Swift.Double
  }
  public struct Author {
    public let identifier: BrokerData.AuthorId
    public let name: Swift.String
    public let position: Swift.String
    public let rating: Swift.Double
    public let logo: BrokerData.ImageResource?
    public let info: Swift.String
    public let methodsInfo: Swift.String
    public let competences: [Swift.String]
    public let stats: BrokerData.InvestIdea.Author.Statistic
    public let userProperies: BrokerData.InvestIdea.Author.UserProperties
    public struct Statistic {
      public let successPercents: Swift.Double
      public let averageYearProfit: Swift.Double
      public static let unknown: BrokerData.InvestIdea.Author.Statistic
    }
    public struct UserProperties {
      public let isFavorite: Swift.Bool
    }
  }
  public struct UserProperties {
    public let isFavorite: Swift.Bool
  }
  public struct OrderProperties {
    public let targetPrice: Swift.Double
    public let stopLoss: Swift.Double?
    public let startPrice: Swift.Double?
  }
}
extension InvestIdea.Author : Swift.Hashable {
  public static func == (lhs: BrokerData.InvestIdea.Author, rhs: BrokerData.InvestIdea.Author) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct InvestIdeaDetails {
  public let idea: BrokerData.InvestIdea
  public let article: Swift.String
  public let orderProperies: BrokerData.InvestIdea.OrderProperties
  public let quote: BrokerData.FinQuote
}
extension InvestIdea : Swift.Hashable {
  public static func == (lhs: BrokerData.InvestIdea, rhs: BrokerData.InvestIdea) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class MBServiceConfigurator : APICore.DefaultAPIServiceConfigurator {
  final public var masterId: Swift.String?
  public init(base url: Foundation.URL, plugins: [APICore.Plugin] = [])
  override final public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  override public init(baseUrl: Foundation.URL)
  override public init(baseUrl: Foundation.URL, sessionManager: APICore.SessionManager = super, bodyEncoding: @escaping APICore.MethodBodyEncoding = super, plugins: [APICore.Plugin] = super, headers: [Swift.String : Swift.String]? = super, requestsErrorBehavior: APICore.RequestErrorBehavior? = super)
  @objc deinit
}
extension URL {
  public struct MyBroker {
    public static let prod: Foundation.URL
    public static let test: Foundation.URL
    public static let testMasterId: Foundation.URL
  }
}
public class PortfelItem : Swift.CustomStringConvertible {
  final public let account: BrokerData.Account?
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public typealias Asset = BrokerData.PortfelMarketItem
public class PortfelMarketItem : BrokerData.PortfelItem {
  final public let finResult: BrokerData.FinResult
  final public let marketCost: BrokerData.Money
  final public let amount: Swift.Double
  @objc deinit
}
final public class PortfelAsset : BrokerData.PortfelMarketItem {
  final public let instrument: BrokerData.FinInstrument
  final public let averagePrice: BrokerData.Price
  override final public var description: Swift.String {
    get
  }
  @objc deinit
}
final public class PortfelInitialMargin : BrokerData.PortfelItem {
  final public let money: BrokerData.Money
  final public let amount: BrokerData.Money
  override final public var description: Swift.String {
    get
  }
  @objc deinit
}
final public class PortfelMoney : BrokerData.PortfelMarketItem {
  final public let currency: BrokerData.Currency
  final public var associatedInstruments: [BrokerData.FinInstrument] {
    get
  }
  override final public var description: Swift.String {
    get
  }
  @objc deinit
}
extension Array where Element == BrokerData.PortfelItem {
  public var shortDebug: Swift.String {
    get
  }
  public var filterMoney: [BrokerData.PortfelMoney] {
    get
  }
  public var filterInitMargin: [BrokerData.PortfelInitialMargin] {
    get
  }
  public var filterAssets: [BrokerData.PortfelAsset] {
    get
  }
}
extension Array where Element == BrokerData.PortfelMarketItem {
  public var sum: (marketCost: BrokerData.Money, finResult: BrokerData.FinResult)? {
    get
  }
}
final public class BRSConfigurator : APICore.APIServiceConfiguratorType {
  final public var requestsErrorBehavior: APICore.RequestErrorBehavior?
  final public var sessionManager: APICore.SessionManager
  final public let bodyEncoding: APICore.MethodBodyEncoding
  final public let baseHeaders: [Swift.String : Swift.String]?
  weak final public var delegate: APICore.APIServiceConfiguratorDelegate?
  final public var plugins: [APICore.Plugin]
  final public var baseUrl: Foundation.URL
  final public let xUserLogin: Swift.String
  final public let merchantId: Swift.String
  final public let account: Swift.String
  public init(plugins: [APICore.Plugin] = [], baseUrl: Foundation.URL, xUserLogin: Swift.String, merchantId: Swift.String, account: Swift.String)
  final public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  @objc deinit
}
extension BRSConfigurator {
  public static func prod(_ plugins: [APICore.Plugin] = []) -> BrokerData.BRSConfigurator
  public static func test(_ plugins: [APICore.Plugin] = []) -> BrokerData.BRSConfigurator
}
extension URL {
  public struct BRS {
    public static let test: Foundation.URL
    public static let prod: Foundation.URL
  }
}
extension Account : Swift.CustomStringConvertible {
}
public typealias TradeAccount = BrokerData.Account
final public class Account : Swift.Codable {
  public static let unknown: BrokerData.Account
  final public let accountId: BrokerData.AccountId
  final public let agreement: BrokerData.Agreement
  final public let number: Swift.String
  final public let kind: BrokerData.Account.Kind
  final public let fullCost: BrokerData.Money
  final public let moneyRUB: BrokerData.Money
  final public let moneyUSD: BrokerData.Money
  final public let moneyEUR: BrokerData.Money
  public enum Kind : Swift.String, Swift.Codable {
    case broker
    case iia
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public init(from decoder: Swift.Decoder) throws
  final public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension Account : Swift.Hashable {
  public static func == (lhs: BrokerData.Account, rhs: BrokerData.Account) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Array where Element == BrokerData.Account {
  public var shortDebug: Swift.String {
    get
  }
  public var numbers: Swift.String {
    get
  }
}
public typealias AuthCredentials = (login: Swift.String, password: Swift.String)
public typealias AuthUserInfo = (name: Swift.String, phone: Swift.String, email: Swift.String, city: Swift.String?)
final public class ETAuthService : APICore.APIService<BrokerData.ETAuthService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  public enum Methods {
    case signUp(BrokerData.AuthCredentials, BrokerData.AuthUserInfo)
    case signUpDemo(BrokerData.AuthUserInfo)
    case signInKeyClock(BrokerData.AuthCredentials)
    case signInBCSPassport(BrokerData.AuthCredentials)
  }
  required public init()
  @objc deinit
}
extension ETAuthService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
  public var overrideBodyEncoding: APICore.BodyEncoding? {
    get
  }
}
extension ETAuthService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case signUp
    case signUpDemo
    case signInKeyClock
    case signInBCSPassport
    public typealias AllCases = [BrokerData.ETAuthService.Methods.MockKey]
    public static var allCases: [BrokerData.ETAuthService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETAuthService.Methods.MockKey? {
    get
  }
}
extension ETAuthService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public struct Dividend {
  public let amount: Swift.Double
  public let paymentDate: Foundation.Date
}
final public class KeyCloakService : APICore.APIService<BrokerData.KeyCloakService.Methods, BrokerData.KeyCloakServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  public enum Methods {
    case token(login: Swift.String, password: Swift.String)
    case tokenBy(refreshToken: Swift.String)
    case resetPassword(login: Swift.String, password: Swift.String, newPassword: Swift.String)
  }
  required public init()
  @objc deinit
}
extension KeyCloakService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension KeyCloakService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case token
    case tokenBy
    case resetPassword
    public typealias RawValue = Swift.String
    public typealias AllCases = [BrokerData.KeyCloakService.Methods.MockKey]
    public static var allCases: [BrokerData.KeyCloakService.Methods.MockKey] {
      get
    }
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.KeyCloakService.Methods.MockKey? {
    get
  }
}
extension KeyCloakService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
extension FinTargetService.Methods {
  public class BaseParams {
    public init(strategyId: BrokerData.StrategyId, aggrementNumber: Swift.String)
    public var asDictionary: [Swift.String : Any] {
      get
    }
    @objc deinit
  }
  public class BindParams : BrokerData.FinTargetService.Methods.BaseParams {
    public init(strategyId: BrokerData.StrategyId, aggrementNumber: Swift.String, bindingType: BrokerData.Strategy.BindingType)
    override public var asDictionary: [Swift.String : Any] {
      get
    }
    override public init(strategyId: BrokerData.StrategyId, aggrementNumber: Swift.String)
    @objc deinit
  }
  public class UnbindParams : BrokerData.FinTargetService.Methods.BaseParams {
    override public init(strategyId: BrokerData.StrategyId, aggrementNumber: Swift.String)
    @objc deinit
  }
  public class ConfirmBindParams : BrokerData.FinTargetService.Methods.BaseParams {
    public init(strategyId: BrokerData.StrategyId, aggrementNumber: Swift.String, bindingType: BrokerData.Strategy.BindingType, smsCode: Swift.String)
    override public var asDictionary: [Swift.String : Any] {
      get
    }
    override public init(strategyId: BrokerData.StrategyId, aggrementNumber: Swift.String)
    @objc deinit
  }
  public class ConfirmUnbindParams : BrokerData.FinTargetService.Methods.BaseParams {
    public init(strategyId: BrokerData.StrategyId, aggrementNumber: Swift.String, smsCode: Swift.String)
    override public var asDictionary: [Swift.String : Any] {
      get
    }
    override public init(strategyId: BrokerData.StrategyId, aggrementNumber: Swift.String)
    @objc deinit
  }
}
extension ETTradingService.Methods {
  public struct SaveRequestParams {
    public var accountId: BrokerData.AccountId
    public var bs: BrokerData.TradingType
    public var price: Swift.Double
    public var stopPrice: Swift.Double?
    public var type: BrokerData.OrderType
    public var instrumentId: BrokerData.InstrumentId
    public var ideaId: BrokerData.IdeaId?
    public var ticker: BrokerData.InstrumentTicker
    public var amount: Swift.Double
    public var tradeAccountMapId: Swift.Int
    public var orderId: BrokerData.OrderId
    public var timeInForce: Swift.String?
    public var offset: Swift.Double?
    public var spread: Swift.Double?
  }
}
final public class ETDepositService : APICore.APIService<BrokerData.ETDepositService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case startOrder(BrokerData.ETDepositService.Methods.ClientId)
    case registerOrder(BrokerData.ETDepositService.Methods.RegisterParams)
    case getOrder(BrokerData.ETDepositService.Methods.Number)
  }
  required public init()
  @objc deinit
}
extension ETDepositService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETDepositService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case startOrder
    case registerOrder
    case getOrder
    public typealias AllCases = [BrokerData.ETDepositService.Methods.MockKey]
    public static var allCases: [BrokerData.ETDepositService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETDepositService.Methods.MockKey? {
    get
  }
}
extension ETDepositService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
final public class IIAGovBondOrder : BrokerData.NewOrder {
  public init(_ tradingInfo: BrokerData.NewOrder.TradingInfo, account: BrokerData.Account?)
  final public var investedSum: Swift.Double {
    get
    set
  }
  final public var investedMoney: BrokerData.Money {
    get
  }
  final public var nominalPrice: BrokerData.Price {
    get
  }
  final public var profitYearMoney: BrokerData.Money {
    get
  }
  final public var taxDeductionMoney: BrokerData.Money {
    get
  }
  final public var totalProfitBy3YearsMoney: BrokerData.Money {
    get
  }
  override public init(_ tradingInfo: BrokerData.NewOrder.TradingInfo, draft: BrokerData.NewOrder.Draft? = super)
  @objc deinit
}
public struct AddressSuggestion {
  public let value: Swift.String?
  public let data: BrokerData.Address
  public init(value: Swift.String?, data: BrokerData.Address)
}
public struct Paging {
  public let offset: Swift.Int
  public let count: Swift.Int
  public init(offset: Swift.Int, count: Swift.Int)
  public static func firsts(_ count: Swift.Int) -> BrokerData.Paging
  public static var firsts20: BrokerData.Paging {
    get
  }
  public static var all: BrokerData.Paging {
    get
  }
  public var next: BrokerData.Paging {
    get
  }
}
public enum InvestIdeasCategory : Swift.CaseIterable {
  case active
  case recommended
  case finished
  case favorited
  case best
  case all
  public static func == (a: BrokerData.InvestIdeasCategory, b: BrokerData.InvestIdeasCategory) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [BrokerData.InvestIdeasCategory]
  public static var allCases: [BrokerData.InvestIdeasCategory] {
    get
  }
}
extension BroData {
  public struct Account {
  }
}
extension BroData.Account {
  public static func iia() -> RxSwift.Single<BrokerData.Account?>
  public static func list(instrumentId: BrokerData.InstrumentId? = nil, currency: BrokerData.Currency = .RUB) -> RxSwift.Single<[BrokerData.Account]>
  public static func listPL(instrumentId: BrokerData.InstrumentId? = nil, currency: BrokerData.Currency) -> RxSwift.Single<[BrokerData.Account]>
}
public struct DepositDetails {
  public let payee: Swift.String
  public let bank: Swift.String
  public let bik: Swift.String
  public let inn: Swift.String
  public let kpp: Swift.String
  public let accountNumber: Swift.String
  public let correspondentAccount: Swift.String
  public let purpose: Swift.String
}
final public class KeyCloakServiceConfigurator : APICore.APIServiceConfiguratorType {
  final public var whenErrorReturnSingle: ((Swift.Error) throws -> RxSwift.Single<Swift.Void>)?
  final public var requestsErrorBehavior: APICore.RequestErrorBehavior?
  final public var sessionManager: APICore.SessionManager
  final public let bodyEncoding: APICore.MethodBodyEncoding
  final public var plugins: [APICore.Plugin]
  final public var baseUrl: Foundation.URL
  final public let baseHeaders: [Swift.String : Swift.String]?
  weak final public var authTokenProvider: APICore.AuthTokenProvider?
  final public var token: APICore.AuthToken? {
    get
    }
  weak final public var delegate: APICore.APIServiceConfiguratorDelegate?
  final public var clientSecret: Swift.String
  final public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  @objc deinit
}
extension KeyCloakServiceConfigurator {
  public static func prod(_ plugins: [APICore.Plugin] = [], clientSecret: Swift.String = "8d7a31cb-d2e3-4e71-b1b9-3fb7b526009e") -> BrokerData.KeyCloakServiceConfigurator
  public static func test(_ plugins: [APICore.Plugin] = [], clientSecret: Swift.String = "6ebd6b9f-4059-4f04-ae80-c07e12c4425f") -> BrokerData.KeyCloakServiceConfigurator
}
extension URL {
  public struct KeyCloack {
    public static let test: Foundation.URL
    public static let prod: Foundation.URL
  }
}
public struct FinInstrumentFull {
  public let instrument: BrokerData.FinInstrument
  public let quote: BrokerData.FinQuote
  public let properties: BrokerData.FinProperties
  public let userProperties: BrokerData.FinUserProperties
  public let assetProperties: BrokerData.FinAssetProperties
  public let info: BrokerData.FinInfo
  public var prices: BrokerData.FinPrices {
    get
  }
  public var lastPriceChange: BrokerData.TradeSessionPriceChange {
    get
  }
  public init(instrument: BrokerData.FinInstrument, quote: BrokerData.FinQuote, properties: BrokerData.FinProperties = .empty, userProperties: BrokerData.FinUserProperties = .blank, assetProperties: BrokerData.FinAssetProperties = .blank, info: BrokerData.FinInfo = .init())
}
extension FinInstrument {
  public static let testApple: BrokerData.FinInstrument
  public static let testGazp: BrokerData.FinInstrument
  public static let testUSDRUB: BrokerData.FinInstrument
}
extension FinInstrument.Prices {
  public static let testMiddle: BrokerData.FinPrices
}
extension FinInstrument.Properties {
  public static let test: BrokerData.FinProperties
}
extension Change {
  public static let testMiddleUSD: BrokerData.Change
  public static let testMiddleRUB: BrokerData.Change
}
extension FinResult {
  public static let positiveUSD: BrokerData.FinResult
}
extension FinYield {
  public static let testMiddle: BrokerData.FinYield
}
extension FinQuote {
  public static let testApple: BrokerData.FinQuote
}
extension PortfelAsset {
  public static let testApple: BrokerData.PortfelAsset
}
extension Account {
  public static var testIIA: BrokerData.Account {
    get
  }
  public static var test: BrokerData.Account {
    get
  }
  public static var testAccounts: [BrokerData.Account] {
    get
  }
}
public struct ETInstrument : Swift.Decodable {
  public let instrumentId: BrokerData.InstrumentId?
  public let assetType: Swift.Int?
  public let assetSubType: Swift.Int?
  public let securCode: Swift.String?
  public let ticker: Swift.String?
  public let classCode: Swift.String?
  public let name: Swift.String?
  public let shortDescription: Swift.String?
  public let fullDescription: Swift.String?
  public let priceStep: Swift.Double?
  public let currency: BrokerData.ETCurrency?
  public let lotSize: Swift.Int?
  public let maturityDate: Foundation.Date?
  public let volume: Swift.Double?
  public let daysToMaturityOrPut: Swift.Int?
  public let dealingCurrency: Swift.String?
  public let initialMargin: Swift.Double?
  public let ai: Swift.Double?
  public let factor: Swift.Double?
  public var midRate: Swift.Double?
  public var price: Swift.Double?
  public var midRateMoney: Swift.Double?
  public var change: Swift.Double?
  public var changePoint: Swift.Double?
  public let yTM: Swift.Double?
  public let highPrice: Swift.Double?
  public let highPriceMoney: Swift.Double?
  public let lowPrice: Swift.Double?
  public let lowPriceMoney: Swift.Double?
  public let openPrice: Swift.Double?
  public let closePrice: Swift.Double?
  public let ask: Swift.Double?
  public let bid: Swift.Double?
  public let notional: Swift.Double?
  public let canOrder: Swift.Int?
  public let hasPosition: BrokerData.BoolInt?
  public let hasIdea: BrokerData.BoolInt?
  public let hasAlert: BrokerData.BoolInt?
  public let hasOrder: BrokerData.BoolInt?
  public let isFavorite: BrokerData.BoolInt?
  public let state: Swift.Int?
  public let timeToOpenTradeSession: Swift.String?
  public let updated: Foundation.Date?
  public init(from decoder: Swift.Decoder) throws
}
extension ETInstrumentService {
  public struct DividendResponse : Swift.Decodable {
    public let dividend: Swift.Double
    public let lastBuyDay: Foundation.Date?
    public let period: Swift.String?
    public let shareHoldersBoard: Swift.String?
    public let reestr: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
}
extension Dividend {
  public static func convert(_ list: [BrokerData.ETInstrumentService.DividendResponse]) -> [BrokerData.Dividend]
}
final public class ETWithdrawService : APICore.APIService<BrokerData.ETWithdrawService.Methods, BrokerData.ETServiceConfigurator> {
  public typealias UserRequestId = Swift.String
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case bankAccount
    case bankAccountSave(BrokerData.ETWithdrawService.Methods.BankAccountSaveParams)
    case bankAccountConfirm(code: Swift.String, BrokerData.ETWithdrawService.UserRequestId)
    case bankAccountRequestCode(BrokerData.ETWithdrawService.UserRequestId)
    case deleteBankAccount(Swift.Int)
    case withdrawalSave(BrokerData.ETWithdrawService.Methods.WithdrawalSaveParams)
    case withdrawalConfirm(code: Swift.String, BrokerData.ETWithdrawService.UserRequestId)
    case withdrawalRequestCode(BrokerData.ETWithdrawService.UserRequestId)
  }
  required public init()
  @objc deinit
}
extension ETWithdrawService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETWithdrawService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case withdrawalSave
    case bankAccountSave
    case bankAccountConfirm
    case withdrawalConfirm
    case withdrawalRequestCode
    case bankAccountRequestCode
    case bankAccount
    case deleteBankAccount
    public typealias AllCases = [BrokerData.ETWithdrawService.Methods.MockKey]
    public static var allCases: [BrokerData.ETWithdrawService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETWithdrawService.Methods.MockKey? {
    get
  }
}
extension ETWithdrawService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public enum SignInDemoResult {
  case success(Swift.String)
  case errorSignUpDemo
  case signUpDemoSuccess
  case signUpDemoStatus7
  case signUpDemoFailed
  case signUpFailed
  case signInBCSPassport(Swift.Error?)
  case signInBCSPassportFailed
}
public enum SignInDemoError : Swift.Error {
  case signUpDemo
  case signUp
  public static func == (a: BrokerData.SignInDemoError, b: BrokerData.SignInDemoError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class ETAuthProvider {
  public init()
  public enum AuthType {
    case bcsPassport
    case keyCloak
    public static func == (a: BrokerData.ETAuthProvider.AuthType, b: BrokerData.ETAuthProvider.AuthType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public func signInUser(authCredentials: BrokerData.AuthCredentials, type: BrokerData.ETAuthProvider.AuthType = .keyCloak, completion: @escaping (Swift.String) -> Swift.Void)
  final public func signInDemo(completion: @escaping (BrokerData.SignInDemoResult) -> Swift.Void)
  final public func signInDemo() -> RxSwift.Single<BrokerData.ETAuthService.SignInResponse>
  final public func signInKeyClock(authCredentials: BrokerData.AuthCredentials) -> RxSwift.Single<BrokerData.ETAuthService.SignInResponse>
  @objc deinit
}
extension JSONDecoder {
  public static let keyCloakJsonDecoder: Foundation.JSONDecoder
}
extension BroData {
  public struct Instrument {
  }
}
extension BroData.Instrument {
  public static func orderBook(finInstrument: BrokerData.FinInstrument) -> RxSwift.Observable<BrokerData.OrderBook>
  public static func quotes(category: BrokerData.FinQuoteCategory) -> RxSwift.Single<[BrokerData.FinQuote]>
  public static func quotesET(category: BrokerData.FinQuoteCategory) -> RxSwift.Single<[BrokerData.FinQuote]>
  public static func quotesML(group: BrokerData.MLService.InstrumentGroup, sort: BrokerData.MLService.SortField = .shortName, direction: BrokerData.MLService.SortDirection = .desc) -> RxSwift.Single<[BrokerData.FinQuote]>
  public static func search(query: Swift.String) -> RxSwift.Single<[BrokerData.FinInstrument]>
  public static func searchET(query: Swift.String) -> RxSwift.Single<[BrokerData.FinInstrument]>
  public static func searchML(query: Swift.String) -> RxSwift.Single<[BrokerData.FinInstrument]>
  public static func setMyListOrder(quotes: [BrokerData.FinQuote]) -> RxSwift.Single<Swift.Void>
  public static func set(isFavorite: Swift.Bool, for instrument: BrokerData.FinInstrument) -> RxSwift.Single<Swift.Void>
  public static func full(for instrument: BrokerData.FinInstrument) -> RxSwift.Single<BrokerData.FinInstrumentFull>
  public static func forecasts(for instrument: BrokerData.FinInstrument) -> RxSwift.Single<[BrokerData.AuthorForecast]>
  public static func forecastConsensus(for instrument: BrokerData.FinInstrument) -> RxSwift.Single<BrokerData.Forecast?>
  public static func coupons(for instrument: BrokerData.FinInstrument) -> RxSwift.Single<[BrokerData.Coupon]>
  public static func dividends(for instrument: BrokerData.FinInstrument) -> RxSwift.Single<[BrokerData.Dividend]>
}
final public class ETInvestIdeasService : APICore.APIService<BrokerData.ETInvestIdeasService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case list(BrokerData.InvestIdeasCategory, BrokerData.InstrumentId?, BrokerData.AuthorId?)
    case single(BrokerData.InvestIdeaId)
    case authors
    case authorFavorite(BrokerData.AuthorId, Swift.Bool)
    case isFavorite(Swift.Bool, BrokerData.IdeaId)
  }
  required public init()
  @objc deinit
}
extension ETInvestIdeasService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETInvestIdeasService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case list
    case single
    case authors
    case authorFavorite
    case isFavorite
    public typealias AllCases = [BrokerData.ETInvestIdeasService.Methods.MockKey]
    public static var allCases: [BrokerData.ETInvestIdeasService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETInvestIdeasService.Methods.MockKey? {
    get
  }
}
extension BroData {
  public struct BankAccount {
    public typealias RequestId = BrokerData.ETWithdrawService.UserRequestId
  }
}
extension BroData.BankAccount {
  public static func list() -> RxSwift.Single<[BrokerData.BankAccount]>
  public static func delete(bankAccount: BrokerData.BankAccount) -> RxSwift.Single<BrokerData.BroData.BankAccount.RequestId>
  public static func save(params: BrokerData.BankAccountChanges) -> RxSwift.Single<BrokerData.BroData.BankAccount.RequestId>
  public static func requestConfirmationSmsCode(requestId: BrokerData.BroData.BankAccount.RequestId) -> RxSwift.Single<Swift.Void>
  public static func confirmRequest(code: Swift.String, requestId: BrokerData.BroData.BankAccount.RequestId) -> RxSwift.Single<Swift.Void>
}
public protocol SocketRequest {
  func socketData(req: Swift.Int) -> Foundation.Data?
}
public typealias SocketAuthToken = Swift.String
public class SocketManager<Request, Response> where Request : BrokerData.SocketRequest {
  public var socketLogEnabled: Swift.Bool
  @objc deinit
}
extension BroData.Account {
  public struct New {
    public typealias SingleData<T> = RxSwift.Single<BrokerData.ShortDobsService.RootResponse<T>> where T : Swift.Decodable
    public typealias SingleStatus = RxSwift.Single<BrokerData.BroData.Account.New.StatusOnly>
    public typealias StatusOnly = BrokerData.ShortDobsService.RootResponse<BrokerData.ShortDobsService.StatusOnly>
    public typealias AuthTokenParams = BrokerData.ShortDobsService.Methods.MobileNumberParams
    public typealias Token = BrokerData.ShortDobsService.MobileNumberResponse
    public typealias SourceIncome = BrokerData.ShortDobsService.Methods.SourceIncomeAnketaParams
    public typealias PassportImage = BrokerData.ShortDobsService.Methods.PassportImageParams
    public typealias PassportPageType = BrokerData.ShortDobsService.Methods.PassportPageType
    public typealias PassportData = BrokerData.ShortDobsService.RequestAnketaDataResponse
    public typealias PassportESIAData = BrokerData.ShortDobsService.RequestEsiaDataResponse
    public typealias Email = Swift.String
    public typealias INN = Swift.String
    public typealias ESIAPage = Swift.String
    public typealias PassportDataConfirmation = BrokerData.ShortDobsService.Methods.ConfirmationAnketaDataParams
    public typealias Documents = BrokerData.ShortDobsService.RequestPrintFormResponse
    public typealias UserData = BrokerData.ShortDobsService.Methods.PassportDataParams
    public typealias ClientService = BrokerData.ShortDobsService.Methods.ClientServiceItemParams
    public typealias ClientServiceList = BrokerData.ShortDobsService.RequestClientServicesListResponse
    public typealias PassportDataForINN = BrokerData.QntSoftService.Methods.InnRequestParams
    public typealias Error = BrokerData.ShortDobsService.Error
    public typealias Suggestion = BrokerData.DDSuggestService.Suggestion
  }
}
extension BroData.Account.New {
  public static func requestSessionAuthToken(_ params: BrokerData.BroData.Account.New.AuthTokenParams) -> BrokerData.BroData.Account.New.SingleData<BrokerData.BroData.Account.New.Token>
  public static func requestSessionValidationSmsCode() -> BrokerData.BroData.Account.New.SingleStatus
  public static func validateSession(with smsCode: Swift.String) -> BrokerData.BroData.Account.New.SingleStatus
  public static func getSessionStatus() -> BrokerData.BroData.Account.New.SingleStatus
  public static func upload(sourceIncomeAnketa: BrokerData.BroData.Account.New.SourceIncome) -> BrokerData.BroData.Account.New.SingleStatus
  public static func upload(passportImage: BrokerData.BroData.Account.New.PassportImage) -> BrokerData.BroData.Account.New.SingleStatus
  public static func getRecognizedPassportData() -> BrokerData.BroData.Account.New.SingleData<BrokerData.BroData.Account.New.PassportData>
  public static func set(clientEmail: BrokerData.BroData.Account.New.Email) -> BrokerData.BroData.Account.New.SingleStatus
  public static func set(clientINN: BrokerData.BroData.Account.New.INN) -> BrokerData.BroData.Account.New.SingleStatus
  public static func confirmPassportData(params: BrokerData.BroData.Account.New.PassportDataConfirmation) -> BrokerData.BroData.Account.New.SingleStatus
  public static func refusePassportData() -> BrokerData.BroData.Account.New.SingleStatus
  public static func requestContractDocuments() -> BrokerData.BroData.Account.New.SingleData<BrokerData.BroData.Account.New.Documents>
  public static func requestContractDocumentsSignSmsCode() -> BrokerData.BroData.Account.New.SingleStatus
  public static func signContractDocuments(with smsCode: Swift.String) -> BrokerData.BroData.Account.New.SingleStatus
  public static func passportData(data: BrokerData.BroData.Account.New.UserData) -> BrokerData.BroData.Account.New.SingleStatus
  public static func loadInn(data: BrokerData.BroData.Account.New.PassportDataForINN) -> RxSwift.Single<BrokerData.BroData.Account.New.INN?>
  public static func isValid(inn: Swift.String) -> RxSwift.Single<Swift.Bool>
  public static func loadAddress(address: Swift.String, count: Swift.Int = 10) -> RxSwift.Single<[BrokerData.AddressSuggestion]>
  public static func clientServices(data: [BrokerData.BroData.Account.New.ClientService]) -> BrokerData.BroData.Account.New.SingleStatus
  public static func clientServicesList() -> BrokerData.BroData.Account.New.SingleData<BrokerData.BroData.Account.New.ClientServiceList>
  public static func requestESIAPage(returnURL: Swift.String) -> BrokerData.BroData.Account.New.SingleData<BrokerData.BroData.Account.New.ESIAPage>
  public static func requestESIAData() -> BrokerData.BroData.Account.New.SingleData<BrokerData.BroData.Account.New.PassportESIAData>
  public static func uploadOptional(passportImage: BrokerData.BroData.Account.New.PassportImage) -> BrokerData.BroData.Account.New.SingleStatus
}
extension PrimitiveSequence where Trait == RxSwift.SingleTrait, Element : BrokerData.ShortDobsServiceResponseType {
  public func validateStatus(throwWhenStatusesNotIn successStatuses: Swift.Int...) -> RxSwift.Single<RxSwift.PrimitiveSequence<Trait, Element>.ElementType>
}
extension RequestBuilder where S == BrokerData.ShortDobsService {
  public func singleBase<T>() -> RxSwift.Single<BrokerData.ShortDobsService.RootResponse<T>> where T : Swift.Decodable
}
public class ETServiceConfigurator : APICore.DefaultAPIServiceConfigurator {
  public init(baseUrl: Foundation.URL, plugins: [APICore.Plugin] = [], appVersion: Swift.String = "1", appBuild: Swift.String = "1", policies: [Swift.String : Alamofire.ServerTrustPolicy]? = nil)
  override public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  override public init(baseUrl: Foundation.URL)
  override public init(baseUrl: Foundation.URL, sessionManager: APICore.SessionManager = super, bodyEncoding: @escaping APICore.MethodBodyEncoding = super, plugins: [APICore.Plugin] = super, headers: [Swift.String : Swift.String]? = super, requestsErrorBehavior: APICore.RequestErrorBehavior? = super)
  @objc deinit
}
extension ETInstrumentService {
  public struct SummaryResponse : Swift.Decodable {
    public let instrument: BrokerData.ETInstrument
    public let nextTradeDate: Foundation.Date?
    public let position: BrokerData.ETInstrumentService.SummaryResponse.Position?
    public struct Position : Swift.Decodable {
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
public typealias NotificationsParams = BrokerData.ETNotificationsService.Methods.NotificationsRequestParams
public typealias NotificationsSaveParams = BrokerData.ETNotificationsService.Methods.SaveRequestParams
extension BroData {
  public struct Alert {
  }
}
extension BroData.Alert {
  public static func notificationList(_ params: BrokerData.NotificationsParams) -> RxSwift.Single<[BrokerData.Alert]>
  public static func save(params: BrokerData.NotificationsSaveParams) -> RxSwift.Single<Swift.Void>
  public static func delete(by alerts: [BrokerData.Alert]) -> RxSwift.Single<Swift.Void>
  public static func markViewed(for alerts: [BrokerData.Alert]) -> RxSwift.Single<Swift.Void>
}
extension ETNotificationsService {
  public struct AlertItem : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
extension ShortDobsService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public struct FAQResponse : Swift.Decodable {
  public let items: [BrokerData.FAQItem]
  public init(from decoder: Swift.Decoder) throws
}
public class FAQItem : Swift.Decodable {
  final public let id: Swift.String
  final public let question: Swift.String
  final public let answer: Swift.String
  final public let bold: [Swift.String]?
  final public let links: [BrokerData.FAQItem.FAQLink]?
  public var showAnswer: Swift.Bool?
  public struct FAQLink : Swift.Decodable {
    public let text: Swift.String
    public let url: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
}
public enum FinQuoteProviderRequest : BrokerData.SocketRequest {
  case HelloReq(token: Swift.String)
  case SubscribeReq(instruments: [Swift.String])
  case UnsubscribeReq(instruments: [Swift.String])
  public func socketData(req: Swift.Int) -> Foundation.Data?
}
extension FinInstrument.UserProperties {
  convenience public init(canOrder: Swift.Int? = nil, hasAlert: BrokerData.BoolInt? = nil, hasPosition: BrokerData.BoolInt? = nil, hasOrder: BrokerData.BoolInt? = nil, favorite: BrokerData.BoolInt? = nil)
}
public struct FinResult {
  public let change: BrokerData.Change
  public let period: BrokerData.Period
  public init(change: BrokerData.Change, period: BrokerData.Period)
  public init(currectValue: Swift.Double, absoluteChange: Swift.Double, currency: BrokerData.Currency, period: BrokerData.Period)
}
public struct Address {
  public let region: Swift.String?
  public let city: Swift.String?
  public let settlement: Swift.String?
  public let street: Swift.String?
  public let house: Swift.String?
  public let block: Swift.String?
  public let flat: Swift.String?
  public init(region: Swift.String? = nil, city: Swift.String? = nil, settlement: Swift.String? = nil, street: Swift.String? = nil, house: Swift.String? = nil, block: Swift.String? = nil, flat: Swift.String? = nil)
}
extension URL {
  public struct ML {
    public static let prod: Foundation.URL
  }
}
final public class ETForecastService : APICore.APIService<BrokerData.ETForecastService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  override final public var serviceHeaders: [Swift.String : Swift.String]? {
    get
  }
  public enum Methods {
    case priceConsunses(instrumentId: Swift.Int)
    case targetPrice(instrumentId: Swift.Int)
  }
  required public init()
  @objc deinit
}
extension ETForecastService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETForecastService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case priceConsunses
    case targetPrice
    public typealias AllCases = [BrokerData.ETForecastService.Methods.MockKey]
    public static var allCases: [BrokerData.ETForecastService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETForecastService.Methods.MockKey? {
    get
  }
}
extension ETForecastService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public struct EcoSystemBCS {
  public let cost: BrokerData.Money
  public let finResult: BrokerData.FinResult
  public let ecoSystems: [BrokerData.EcoSystemBCS.EcoSystem]
  public struct EcoSystem {
    public let name: Swift.String
    public let type: BrokerData.EcoSystemBCS.EcoSystem.Type
    public let cost: BrokerData.Money
    public let change: BrokerData.Change
    public var products: [BrokerData.EcoSystemBCS.EcoSystem.Product]
    public enum `Type` {
      case bcsBroker
      case bcsPremier
      case bcsBank
      case moneyInBroker
      case unknown
      public static func == (a: BrokerData.EcoSystemBCS.EcoSystem.Type, b: BrokerData.EcoSystemBCS.EcoSystem.Type) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public struct Product {
      public let name: Swift.String
      public let cost: BrokerData.Money
      public let change: BrokerData.Change
    }
  }
}
public struct AuthorForecast {
  public var forecast: BrokerData.Forecast
  public var author: Swift.String
}
@objc public class RealmFinInstrument : RealmSwift.Object {
  @objc override public static func indexedProperties() -> [Swift.String]
  @objc override public static func primaryKey() -> Swift.String?
  @objc required dynamic public init()
  @objc deinit
}
extension ETNotificationsService.Methods {
  public enum AlertType : Swift.Int {
    case active, complete
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public struct NotificationsRequestParams {
    public init(instrument: BrokerData.FinInstrument?, status: BrokerData.ETNotificationsService.Methods.AlertType)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
  public struct SaveRequestParams {
    public init(alertId: BrokerData.AlertId, instrument: BrokerData.FinInstrument, price: Swift.Double)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
}
final public class FinTargetConfigurator : APICore.APIServiceConfiguratorType {
  final public var requestsErrorBehavior: APICore.RequestErrorBehavior?
  final public var sessionManager: APICore.SessionManager
  final public let bodyEncoding: APICore.MethodBodyEncoding
  final public let baseHeaders: [Swift.String : Swift.String]?
  weak final public var delegate: APICore.APIServiceConfiguratorDelegate?
  final public var plugins: [APICore.Plugin]
  final public var baseUrl: Foundation.URL
  public init(plugins: [APICore.Plugin] = [], baseUrl: Foundation.URL)
  final public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  @objc deinit
}
extension FinTargetConfigurator {
  public static func prod(_ plugins: [APICore.Plugin] = []) -> BrokerData.FinTargetConfigurator
}
extension URL {
  public struct FinTarget {
    public static let prod: Foundation.URL
  }
}
final public class EcoSystemBCSConfigurator : APICore.APIServiceConfiguratorType {
  final public var requestsErrorBehavior: APICore.RequestErrorBehavior?
  final public var sessionManager: APICore.SessionManager
  final public let bodyEncoding: APICore.MethodBodyEncoding
  final public let baseUrl: Foundation.URL
  final public var plugins: [APICore.Plugin]
  final public let baseHeaders: [Swift.String : Swift.String]?
  weak final public var delegate: APICore.APIServiceConfiguratorDelegate?
  public init(plugins: [APICore.Plugin] = [])
  final public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  @objc deinit
}
public enum Period {
  case `default`
  case yesterday
  case week
  case month
  case halfYear
  case year
  case custom(from: Foundation.Date, to: Foundation.Date)
}
extension Period {
  public var from: Foundation.Date {
    get
  }
  public var to: Foundation.Date {
    get
  }
}
extension Period : Swift.Equatable {
  public static func == (lhs: BrokerData.Period, rhs: BrokerData.Period) -> Swift.Bool
}
public enum FeatureAvailabilityKind {
  case on, off, beta
  public init(configValue: Swift.String)
  public static func == (a: BrokerData.FeatureAvailabilityKind, b: BrokerData.FeatureAvailabilityKind) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class Best2PayConfigurator : APICore.APIServiceConfiguratorType {
  final public var requestsErrorBehavior: APICore.RequestErrorBehavior?
  final public var sessionManager: APICore.SessionManager
  final public let bodyEncoding: APICore.MethodBodyEncoding
  final public let baseHeaders: [Swift.String : Swift.String]?
  weak final public var delegate: APICore.APIServiceConfiguratorDelegate?
  final public var plugins: [APICore.Plugin]
  final public var baseUrl: Foundation.URL
  public init(plugins: [APICore.Plugin] = [], baseUrl: Foundation.URL)
  final public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  @objc deinit
}
extension Best2PayConfigurator {
  public static func prod(_ plugins: [APICore.Plugin] = []) -> BrokerData.Best2PayConfigurator
  public static func test(_ plugins: [APICore.Plugin] = []) -> BrokerData.Best2PayConfigurator
}
extension URL {
  public struct Best2Pay {
    public static let test: Foundation.URL
    public static let prod: Foundation.URL
  }
}
extension QntSoftService.Methods {
  public struct InnRequestParams {
    public init(passportSeries: Swift.String, passportNum: Swift.String, passportIssuedDate: Foundation.Date, firstName: Swift.String, secondName: Swift.String, fatherName: Swift.String, birdthDate: Foundation.Date, useCache: Swift.Int = 1)
    public static var testData: BrokerData.QntSoftService.Methods.InnRequestParams {
      get
    }
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
}
extension EcoSystemBCSService {
  public struct Result : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
extension BroData {
  public struct News {
  }
}
extension BroData.News {
  public struct ListFilter {
    public let category: BrokerData.NewsCategory?
    public let tags: Swift.String?
    public let paging: BrokerData.Paging
    public let since: Foundation.Date?
    public init(category: BrokerData.NewsCategory? = nil, tags: Swift.String? = nil, paging: BrokerData.Paging = .firsts(100), since: Foundation.Date? = nil)
    public static let all: BrokerData.BroData.News.ListFilter
  }
  public static func list(filter: BrokerData.BroData.News.ListFilter) -> RxSwift.Single<[BrokerData.News]>
  public static func details(for id: BrokerData.NewsId) -> RxSwift.Single<BrokerData.NewsDetails>
}
final public class QntSoftService : APICore.APIService<BrokerData.QntSoftService.Methods, BrokerData.QntSoftServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case inn(BrokerData.QntSoftService.Methods.InnRequestParams)
    case validate(inn: Swift.String)
  }
  required public init()
  @objc deinit
}
extension QntSoftService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension QntSoftService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case inn
    case validate
    public typealias AllCases = [BrokerData.QntSoftService.Methods.MockKey]
    public static var allCases: [BrokerData.QntSoftService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.QntSoftService.Methods.MockKey? {
    get
  }
}
extension QntSoftService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public typealias User = BrokerData.BroData.User
extension BroData {
  final public class User : Swift.Codable {
    final public var login: Swift.String, phone: Swift.String, email: Swift.String, name: Swift.String
    final public var accounts: [BrokerData.TradeAccount]? {
      get
      }
    final public var iia: BrokerData.TradeAccount? {
      get
    }
    final public var hasIIA: Swift.Bool {
      get
    }
    final public let properties: BrokerData.BroData.User.Properties, settings: BrokerData.BroData.User.Settings
    public init(login: Swift.String, phone: Swift.String, email: Swift.String, name: Swift.String, properties: BrokerData.BroData.User.Properties, settings: BrokerData.BroData.User.Settings, accounts: [BrokerData.TradeAccount] = [])
    public static let unknown: BrokerData.BroData.User
    public init(from decoder: Swift.Decoder) throws
    @objc deinit
    public func encode(to encoder: Swift.Encoder) throws
  }
}
extension BroData.User {
  final public class Properties : Swift.Codable {
    final public var personaBrokerAvailable: Swift.Bool {
      get
      }
    final public var marketingCampaign: BrokerData.MarketingCampaign?
    public init(personaBrokerAvailable: Swift.Bool)
    public static let unknown: BrokerData.BroData.User.Properties
    public init(from decoder: Swift.Decoder) throws
    @objc deinit
    public func encode(to encoder: Swift.Encoder) throws
  }
}
extension BroData.User {
  final public class Settings : Swift.Codable {
    final public var orderConfirmationType: BrokerData.OrderConfirmType {
      get
      }
    final public var defaultCurrency: BrokerData.Currency {
      get
    }
    public init(orderConfirmationType: BrokerData.OrderConfirmType)
    public static let unknown: BrokerData.BroData.User.Settings
    public init(from decoder: Swift.Decoder) throws
    @objc deinit
    public func encode(to encoder: Swift.Encoder) throws
  }
}
extension BroData.User {
  public static func current() -> RxSwift.Single<BrokerData.User>
  public static func setConfirmationOrderTypeSms() -> RxSwift.Single<Swift.Bool>
  public static func setConfirmationOrderTypePIN(by pin: BrokerData.PIN) -> RxSwift.Single<BrokerData.UserRequestId>
  public static func confirmConfirmationOrderType(by userRequestId: BrokerData.UserRequestId, code: Swift.String) -> RxSwift.Single<Swift.Void>
}
extension BroData.User : Swift.CustomStringConvertible {
}
extension BroData.User.Properties : Swift.CustomStringConvertible {
}
extension BroData.User.Settings : Swift.CustomStringConvertible {
}
extension BroData.User {
  final public var info: Swift.String {
    get
  }
}
public struct Base64Image : Swift.Decodable {
  public let image: UIKit.UIImage?
  public let resource: BrokerData.ImageResource?
  public init(from decoder: Swift.Decoder) throws
}
extension Best2PayService {
  public struct PaymentComissionResponse : Swift.Decodable {
    public let commissionAmount: Swift.Double
    public let paymentId: Swift.String
    public let errorCode: Swift.String?
    public let errorMessage: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct AcceptPaymentResponse : Swift.Decodable {
    public let paymentId: Swift.Int
    public let status: Swift.String?
    public let acsurl: Swift.String
    public let termUrl: Swift.String
    public let md: Swift.String
    public let paReq: Swift.String
    public let errorCode: Swift.String?
    public let errorMessage: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct PaymentStatusResponse : Swift.Decodable {
    public let paymentId: Swift.Int
    public let cardToken: Swift.String?
    public let status: Swift.String
    public let errorCode: Swift.String?
    public let errorMessage: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
}
extension ETDepositService.Methods {
  public typealias ClientId = Swift.Int
  public typealias Number = Swift.Int
  public struct RegisterParams {
    public init(amount: Swift.Double, clientId: Swift.Int, tradeFloorId: Swift.Int)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
}
public struct Pips : Swift.Codable {
  public let value: Swift.Double
  public var fractDigits: Swift.Int {
    get
  }
  public init(_ value: Swift.Double?)
  public init(decimal value: Foundation.NSDecimalNumber?)
  public func isSatisfy(_ value: Swift.Double) -> Swift.Bool
  public static let `default`: BrokerData.Pips
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Pips : Swift.Equatable {
  public static func == (lhs: BrokerData.Pips, rhs: BrokerData.Pips) -> Swift.Bool
}
extension Double {
  public func string(pips: BrokerData.Pips, unsignificantZero: Swift.Bool = true) -> Swift.String
}
extension BroData.Security {
  public struct ChangeTempPassword {
    public typealias RequestId = Swift.String
    public typealias Status = Swift.Int
    public enum InvalidPasswordCause {
      case sameAsLastFive
      case valid
      public static func == (a: BrokerData.BroData.Security.ChangeTempPassword.InvalidPasswordCause, b: BrokerData.BroData.Security.ChangeTempPassword.InvalidPasswordCause) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public static func setAccessToken(token: Swift.String)
  }
}
extension BroData.Security.ChangeTempPassword {
  public static func isPasswordValid(password: Swift.String) -> RxSwift.Single<BrokerData.BroData.Security.ChangeTempPassword.InvalidPasswordCause?>
  public static func requestConfirmationSmsCode(newPassword: Swift.String, question: Swift.String, answer: Swift.String) -> RxSwift.Single<BrokerData.BroData.Security.ChangeTempPassword.RequestId>
  public static func confirmRequest(code: Swift.String, requestId: BrokerData.BroData.Security.ChangeTempPassword.RequestId) -> RxSwift.Single<BrokerData.BroData.Security.ChangeTempPassword.Status>
}
public struct QRCodePayment {
  public let link: Swift.String
  public let image: Foundation.Data
}
extension ETPasswordService {
  public struct TempPasswordChangePrepareResponse : Swift.Decodable {
    public struct SessionData : Swift.Decodable {
      public let tempPasswordChangeSessionId: Swift.String
      public init(from decoder: Swift.Decoder) throws
    }
    public let status: Swift.Int
    public let data: BrokerData.ETPasswordService.TempPasswordChangePrepareResponse.SessionData
    public init(from decoder: Swift.Decoder) throws
  }
  public struct StatusResponse : Swift.Decodable {
    public let status: Swift.Int
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class EcoSystemBCSService : APICore.APIService<BrokerData.EcoSystemBCSService.Methods, BrokerData.EcoSystemBCSConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case getProductsEco(period: BrokerData.Period, cookie: Swift.String)
    case login
  }
  required public init()
  @objc deinit
}
extension EcoSystemBCSService.Methods : Moya.AccessTokenAuthorizable {
  public var authorizationType: Moya.AuthorizationType {
    get
  }
}
extension EcoSystemBCSService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
  public var headers: [Swift.String : Swift.String]? {
    get
  }
}
extension EcoSystemBCSService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case getProductsEco
    case login
    public typealias AllCases = [BrokerData.EcoSystemBCSService.Methods.MockKey]
    public static var allCases: [BrokerData.EcoSystemBCSService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.EcoSystemBCSService.Methods.MockKey? {
    get
  }
}
extension EcoSystemBCSService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public typealias Storage = BrokerData.BroData.Storage
extension BroData {
  final public class Storage {
    public static let shared: BrokerData.BroData.Storage
    final public func getInstrument(by identifier: BrokerData.Identifier) -> BrokerData.FinInstrument?
    @objc deinit
  }
}
extension BroData.Storage {
  public static func savePortfelPeriod(_ period: BrokerData.Period)
  public static func getPortfelPeriod() -> BrokerData.Period?
  public static func saveEcoSystemPeriod(_ period: BrokerData.Period)
  public static func getEcoSystemPeriod() -> BrokerData.Period?
  public static func savePortfelSelectedAccounts(_ accounts: [BrokerData.Account])
  public static func getPortfelSelectedAccounts() -> [BrokerData.Account]
  public static func saveTradingSelectedAccount(_ account: BrokerData.Account)
  public static func getTradingSelectedAccount() -> BrokerData.Account?
  public static func savePortfelCollapsing(_ sectionStates: [Swift.String : Swift.Bool])
  public static func getPortfelCollapsing() -> [Swift.String : Swift.Bool]
  public static func saveShowRateApp()
  public static func getShowRateApp() -> Swift.Bool
  public static func saveMainTab(_ tabIndex: Swift.Int)
  public static func getMainTab() -> Swift.Int?
  public static func saveBetaDataSwitchState(_ state: Swift.Bool)
  public static func getBetaDataSwitchState() -> Swift.Bool
}
extension DDSuggestService {
  public struct Response : Swift.Decodable {
    public let suggestions: [BrokerData.DDSuggestService.Suggestion]
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Suggestion : Swift.Decodable {
    public let value: Swift.String?
    public let data: BrokerData.DDSuggestService.Address
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Address : Swift.Decodable {
    public let region_with_type: Swift.String?
    public let city_with_type: Swift.String?
    public let settlement_with_type: Swift.String?
    public let street_with_type: Swift.String?
    public let house: Swift.String?
    public let block: Swift.String?
    public let flat: Swift.String?
    public init(region: Swift.String? = nil, city: Swift.String? = nil, settlement: Swift.String? = nil, street: Swift.String? = nil, house: Swift.String? = nil, block: Swift.String? = nil, flat: Swift.String? = nil)
    public init(from decoder: Swift.Decoder) throws
  }
}
public struct ClientFeedBack : Swift.CustomStringConvertible {
  public let description: Swift.String
  public init(text: Swift.String, estimate: Swift.String?)
}
extension FinTargetService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case strategies
    case strategy
    case bind
    case unbind
    case confirmBind
    case confirmUnbind
    case clientProfile
    public typealias AllCases = [BrokerData.FinTargetService.Methods.MockKey]
    public static var allCases: [BrokerData.FinTargetService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.FinTargetService.Methods.MockKey? {
    get
  }
}
extension FinTargetService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
extension ETPortfelService {
  public struct TableOrderResponse : Swift.Decodable {
    public let orderId: Swift.Int
    public let status: Swift.Int
    public let price: Swift.Double
    public let stopPrice: Swift.Double?
    public let payment: Swift.Double
    public let amount: Swift.Double
    public let type: Swift.Int
    public let bS: Swift.Int
    public let client: Swift.String
    public let date: Foundation.Date
    public let instrument: BrokerData.ETInstrument
    public let error: Swift.String?
    public let account: Swift.String?
    public let accountId: BrokerData.AccountId?
    public init(from decoder: Swift.Decoder) throws
  }
}
public typealias Chart = BrokerData.BroData.Chart
extension BroData {
  public struct Chart {
  }
}
extension BroData.Chart {
  public static func getPortfelURL(currency: BrokerData.Currency, period: BrokerData.Period = .default, accounts: [BrokerData.Account] = [], options: Swift.String) -> Foundation.URL
  public static func getInstrumentURL(instrument: BrokerData.FinInstrument, period: BrokerData.Period = .default, isCandle: Swift.Bool, options: Swift.String) -> Foundation.URL
}
extension ETPortfelService {
  public struct PLByInstrumentResponse : Swift.Decodable {
    public let assetType: Swift.Int
    public let assetSubType: Swift.Int?
    public let marketValue: Swift.Double
    public let aquisition: Swift.Double
    public let totalPL: Swift.Double
    public let totalPLInstr: Swift.Double
    public let yield: Swift.Double
    public let amount: Swift.Double
    public let avgCostPrice: Swift.Double
    public let operationTypeId: Swift.Int
    public let instrument: BrokerData.ETInstrument?
    public let currency: BrokerData.ETCurrency?
    public init(from decoder: Swift.Decoder) throws
  }
}
extension FinInstrument {
  public static let minFin: BrokerData.FinInstrument
}
final public class Promo : Swift.Decodable {
  final public let identifier: Swift.String
  final public let expiredAt: Foundation.Date?
  final public let showPeriod: BrokerData.Promo.Period?
  final public var isActual: Swift.Bool {
    get
  }
  final public var isExpired: Swift.Bool {
    get
  }
  final public func canShow(lastShowedAt: Foundation.TimeInterval) -> Swift.Bool
  public static let test: BrokerData.Promo
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case identifier
    case available
    case expiredAt
    case showPeriod
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(identifier: Swift.String, available: Swift.Bool = true, expiredAt: Foundation.Date? = nil, showPeriod: BrokerData.Promo.Period? = nil)
  public init(from decoder: Swift.Decoder) throws
  @objc deinit
}
extension Promo {
  public enum TimeFrame : Swift.String, Swift.Decodable {
    case hour
    case minute
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Period : Swift.Decodable {
    public let timeFrame: BrokerData.Promo.TimeFrame
    public let value: Swift.Int
    public static let everyMinute: BrokerData.Promo.Period
    public static let everyWeek: BrokerData.Promo.Period
    public func add(to date: Foundation.Date) -> Foundation.Date?
    public var shortDescription: Swift.String {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
extension Logger.Scope {
  public static let promo: BCSSwiftTools.Logger.Scope
}
extension ShortDobsService {
  public enum Error : Swift.Error {
    case invalidStatus(status: Swift.Int)
    case noData(status: Swift.Int)
    case sessionExpired(status: Swift.Int)
    case innMissing(status: Swift.Int)
  }
  public struct StatusOnly : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
  public struct MobileNumberResponse : Swift.Decodable {
    public let token: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct RequestEsiaDataResponse : Swift.Decodable {
    public let personInfo: BrokerData.ShortDobsService.RequestEsiaDataResponse.PersonInfo?
    public let personDocument: BrokerData.ShortDobsService.RequestEsiaDataResponse.PersonDocument?
    public let trustedEsiaAccount: Swift.Bool?
    public struct PersonInfo : Swift.Decodable {
      public let firstName: Swift.String?
      public let middleName: Swift.String?
      public let lastName: Swift.String?
      public init(from decoder: Swift.Decoder) throws
    }
    public struct PersonDocument : Swift.Decodable {
      public let series: Swift.String?
      public let issueDate: Swift.String?
      public let number: Swift.String?
      public let issuedBy: Swift.String?
      public let issueId: Swift.String?
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct RequestAnketaDataResponse : Swift.Decodable {
    public let fio: Swift.String
    public let birdthInfo: Swift.String
    public let passIdent: Swift.String
    public let inn: Swift.String
    public let registration: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct RequestPrintFormResponse : Swift.Decodable {
    public let appFormAced: Swift.String?
    public let appAcrd: Swift.String?
    public let appComplexService: Swift.String?
    public let appComplexServiceIIS: Swift.String?
    public let noticeUsba: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct RequestClientServicesListResponse : Swift.Decodable {
    public enum ClientServiceStatus {
      case error
      case inProgress
      case willNotOpen
      case open
      public static func == (a: BrokerData.ShortDobsService.RequestClientServicesListResponse.ClientServiceStatus, b: BrokerData.ShortDobsService.RequestClientServicesListResponse.ClientServiceStatus) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public let brokerageService: BrokerData.ShortDobsService.RequestClientServicesListResponse.ClientServiceStatus
    public let iia: BrokerData.ShortDobsService.RequestClientServicesListResponse.ClientServiceStatus
    public init(from decoder: Swift.Decoder) throws
  }
  public struct RootResponse<DT> : Swift.Decodable, BrokerData.ShortDobsServiceResponseType where DT : Swift.Decodable {
    public let statusCode: Swift.Int
    public let data: DT?
    public func dataOrThrow() throws -> DT
    public init(from decoder: Swift.Decoder) throws
    public init(code: Swift.Int, data: DT?)
  }
}
public protocol ShortDobsServiceResponseType {
  var statusCode: Swift.Int { get }
}
extension ShortDobsServiceResponseType {
  public func validate(statuses: [Swift.Int]) throws -> Swift.Bool
}
extension InstrumentLogoProvider : BCSSwiftTools.ImageProvider {
  final public func getImage(identifier: Swift.String, completion: @escaping (UIKit.UIImage?) -> Swift.Void)
}
final public class MLService : APICore.APIService<BrokerData.MLService.Methods, BrokerData.MLServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case sortQuotesGroups(BrokerData.MLService.InstrumentGroup, BrokerData.MLService.SortField, BrokerData.MLService.SortDirection)
    case instrumentSearch(Swift.String)
  }
  required public init()
  @objc deinit
}
extension MLService.Methods : Moya.AccessTokenAuthorizable {
  public var authorizationType: Moya.AuthorizationType {
    get
  }
}
extension MLService {
  public enum InstrumentGroup : Swift.String, Swift.CaseIterable, Swift.Decodable {
    case blueChips
    case american
    case seltForex
    case rubleBonds
    case euroBonds
    case futures
    case etn
    case fund
    case etf
    case commodityMarkets
    case worldIndexes
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public typealias AllCases = [BrokerData.MLService.InstrumentGroup]
    public static var allCases: [BrokerData.MLService.InstrumentGroup] {
      get
    }
  }
  public enum SortField : Swift.String {
    case lastPrice
    case priceChange
    case tradeVolum
    case shortName
    case yield
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SortDirection : Swift.String {
    case asc
    case desc
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
extension MLService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension MLService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case sortQuotesGroups, instrumentSearch
    public typealias AllCases = [BrokerData.MLService.Methods.MockKey]
    public static var allCases: [BrokerData.MLService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.MLService.Methods.MockKey? {
    get
  }
}
extension MLService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
extension ETInstrumentService {
  public struct CouponResponse : Swift.Decodable {
    public let rate: Swift.Double
    public let amount: Swift.Double
    public let currency: BrokerData.ETCurrency
    public let paymentDate: Foundation.Date
    public init(from decoder: Swift.Decoder) throws
  }
}
extension Coupon {
  public static func convert(_ list: [BrokerData.ETInstrumentService.CouponResponse]) -> [BrokerData.Coupon]
}
public struct FinYield {
  public let percents: Swift.Double
  public init(percents: Swift.Double? = nil)
  public static let zero: BrokerData.FinYield
  public static let unknown: BrokerData.FinYield
}
public struct Trade {
  public let id: BrokerData.TradeId
  public let instrument: BrokerData.FinInstrument
  public let tradingType: BrokerData.TradingType
  public let completeAt: Foundation.Date
  public let amount: Swift.Double
  public let price: BrokerData.Price
  public let payment: BrokerData.Money
  public let account: BrokerData.Account?
}
public enum FinQuoteCategory : Swift.CaseIterable {
  case user
  case worldIndex
  case blueChips
  case future
  case leadUp
  case leadDown
  case adrgdr
  case commodityMarkets
  case currency
  case forex
  case american
  case rubleBonds
  case euroObligations
  case etf
  case structuralProduct
  case crypto
  case pif
  case notes
  public static func == (a: BrokerData.FinQuoteCategory, b: BrokerData.FinQuoteCategory) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [BrokerData.FinQuoteCategory]
  public static var allCases: [BrokerData.FinQuoteCategory] {
    get
  }
}
extension BroData {
  public struct Portfel {
    public static var defaultCacheRule: RxObservableCache.CacheRule
  }
}
extension BroData.Portfel {
  public static func requestPLByInstrument(currency: BrokerData.Currency, period: BrokerData.Period = .default, accountsIds: [Swift.Int] = [], instrumentId: BrokerData.InstrumentId? = nil, cacheRule: RxObservableCache.CacheRule = defaultCacheRule) -> RxSwift.Single<[BrokerData.ETPortfelService.PLByInstrumentResponse]>
  public static func portfel(currency: BrokerData.Currency, period: BrokerData.Period = .default, accounts: [BrokerData.Account]) -> RxSwift.Single<BrokerData.Portfel>
  public static func items(by instrument: BrokerData.FinInstrument, account: BrokerData.Account) -> RxSwift.Single<BrokerData.PortfelMarketItem?>
  public static func items(by instrument: BrokerData.FinInstrument, accounts: [BrokerData.Account] = []) -> RxSwift.Single<[BrokerData.PortfelMarketItem]>
  public static func items(accounts: [BrokerData.Account] = [], moneyIn currency: BrokerData.Currency = .RUB, finResultFor period: BrokerData.Period = .default) -> RxSwift.Single<[BrokerData.PortfelItem]>
  public static func orders(by instrument: BrokerData.FinInstrument) -> RxSwift.Single<[BrokerData.Order]>
  public static func orders(accounts: [BrokerData.Account]) -> RxSwift.Single<[BrokerData.Order]>
  public static func trades(by instrument: BrokerData.FinInstrument, paging: BrokerData.Paging = .firsts20) -> RxSwift.Single<[BrokerData.Trade]>
  public static func trades(accounts: [BrokerData.Account], paging: BrokerData.Paging = .firsts20) -> RxSwift.Single<[BrokerData.Trade]>
  public static func tradesWithDate(accounts: [BrokerData.Account], period: BrokerData.Period = .default) -> RxSwift.Single<[BrokerData.Trade]>
  public static func nonTradeOperations(accounts: [BrokerData.Account] = [], paging: BrokerData.Paging = .firsts20) -> RxSwift.Single<[BrokerData.NonTradeOperation]>
  public static func ecosystem(period: BrokerData.Period) -> RxSwift.Single<BrokerData.EcoSystemBCS>
  public enum EcoSystemError : Swift.Error {
    case noCookie
    case noToken
    public static func == (a: BrokerData.BroData.Portfel.EcoSystemError, b: BrokerData.BroData.Portfel.EcoSystemError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension String {
  public static let unknown: Swift.String
}
public struct Bank {
  public let name: Swift.String
  public let bik: Swift.String
}
public enum FinQuoteProviderResponse : Swift.Decodable {
  case HelloResp
  case SubscribeResp([BrokerData.FinQuoteProviderResponse.Prices])
  case MarketDataChangeResp([BrokerData.FinQuoteProviderResponse.Prices])
  case UnsubscribeResp
  case unknown
  public struct Prices : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ETForecastService {
  public struct Response {
    public typealias Column = [Swift.String : Swift.String]
    public typealias Row = [Swift.String]
    public let columns: [BrokerData.ETForecastService.Response.Column]
    public let rows: [BrokerData.ETForecastService.Response.Row]
    public let availableKeys: [BrokerData.ETForecastService.Response.Key : Swift.Int]
    public enum Key : Swift.String {
      case targetPrice
      case upsidePCT
      case recomendationName
      case marketMarkerName
      case exchenageTargetPrice
      public typealias RawValue = Swift.String
      public init?(rawValue: Swift.String)
      public var rawValue: Swift.String {
        get
      }
    }
    public func parceDeimalOrDefault(by key: BrokerData.ETForecastService.Response.Key, for row: BrokerData.ETForecastService.Response.Row) -> Foundation.NSDecimalNumber
    public func getValueIfPresent(by key: BrokerData.ETForecastService.Response.Key, for row: BrokerData.ETForecastService.Response.Row) -> Swift.String?
  }
}
extension ETForecastService.Response : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension AuthorForecast {
  public static func convert(_ responce: BrokerData.ETForecastService.Response) -> [BrokerData.AuthorForecast]
}
extension Forecast {
  public static func convert(_ responce: BrokerData.ETForecastService.Response) -> [BrokerData.Forecast]
}
final public class InstrumentDB {
  public static let shared: BrokerData.InstrumentDB
  final public var realm: RealmSwift.Realm? {
    get
    set
  }
  final public func touch()
  final public func find(associatedCurrency: BrokerData.Currency) -> [BrokerData.FinInstrument]
  final public func get(etId: Swift.Int) -> BrokerData.FinInstrument?
  final public func get(ticker: Swift.String, classCode: Swift.String) -> BrokerData.FinInstrument?
  final public func addOrUpdate(instrument: BrokerData.FinInstrument)
  final public func delete(instrument: BrokerData.FinInstrument)
  final public func setNeedReloadInstrument(etId: Swift.Int)
  final public func setNeedReloadInstrument(ticker: Swift.String, classCode: Swift.String)
  @objc deinit
}
extension Logger.Scope {
  public static let instrumentDB: BCSSwiftTools.Logger.Scope
}
extension ETPortfelService {
  public struct NonTradeOperationResponse : Swift.Decodable {
    public let operationId: BrokerData.Id
    public let type: Swift.Int
    public let status: Swift.Int
    public let amount: Swift.Double
    public let price: Swift.Double
    public let date: Foundation.Date
    public let instrument: BrokerData.ETInstrument
    public let account: BrokerData.ETPortfelService.NonTradeOperationResponse.AccountResponse
    public struct AccountResponse : Swift.Decodable {
      public let accountId: Swift.Int
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
extension QntSoftService {
  public typealias Inn = Swift.Int64
  public struct InnResponse : Swift.Decodable {
    public let inn: BrokerData.QntSoftService.Inn?
    public let ok: Swift.Bool
    public init(from decoder: Swift.Decoder) throws
  }
  public struct ValidateResponse : Swift.Decodable {
    public let valid: Swift.Bool
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class ETPortfelService : APICore.APIService<BrokerData.ETPortfelService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case tableOrder(BrokerData.ETPortfelService.Methods.TableOrderRequestParams)
    case tableTrade(BrokerData.ETPortfelService.Methods.TableTradeRequestParams)
    case tableTradeNoPaging(BrokerData.ETPortfelService.Methods.TableTradeNoPagingRequestParams)
    case plByInstrument(BrokerData.ETPortfelService.Methods.PLByInstrumentRequestParams)
    case paymentDetails(currencyCode: Swift.String)
    case nonTradeOperation(BrokerData.ETPortfelService.Methods.NonTradeOperationRequestParams)
  }
  required public init()
  @objc deinit
}
extension ETPortfelService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETPortfelService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case plByInstrument
    case tableOrder
    case tableTrade
    case paymentDetails
    case nonTradeOperation
    public typealias AllCases = [BrokerData.ETPortfelService.Methods.MockKey]
    public static var allCases: [BrokerData.ETPortfelService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETPortfelService.Methods.MockKey? {
    get
  }
}
extension ETPortfelService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public struct DepositOrder {
  public let number: Swift.Int
  public let accountPay: Swift.String
  public let cardMask: Swift.String
  public let amountPay: Swift.Double
  public let ucsStatus: Swift.String
  public let agreement: Swift.String
  public let status: Swift.Int
  public let date: Foundation.Date
  public let tradeFloor: Swift.String
  public var dateValue: Swift.String {
    get
  }
  public var amountMoney: BrokerData.Money {
    get
  }
}
public struct Strategy {
  public let identifier: BrokerData.StrategyId
  public let name: Swift.String
  public let rating: Swift.Double
  public let investProfile: BrokerData.Strategy.InvestProfile
  public let author: BrokerData.Strategy.Author
  public let image: BrokerData.ImageResource?
  public let tag: Swift.String
  public let infoHTML: Swift.String
  public let descriptionHTML: Swift.String
  public let actualProfit: BrokerData.Money
  public let estimatedProfit: BrokerData.Money
  public let estimatedDrawdown: BrokerData.Money
  public let subscriptionThreshold: BrokerData.Money
  public let clientAccountsAvailability: [BrokerData.Strategy.ClientAccountAvailability]
  public let durationDays: Swift.Int
  public let durationText: Swift.String
  public let bindingType: BrokerData.Strategy.BindingType
  public var bindingStatus: BrokerData.Strategy.BindingStatus {
    get
  }
}
extension Strategy {
  public struct InvestProfile {
    public let id: Swift.Int
    public let name: Swift.String
    public let description: Swift.String
  }
  public struct Author {
    public let name: Swift.String
    public let email: Swift.String
    public let company: Swift.String
    public let position: Swift.String
    public let photo: BrokerData.ImageResource?
  }
  public struct ClientAccountAvailability {
    public let agreementId: Swift.String
    public let agreementNumber: Swift.String
    public let bindingStatus: BrokerData.Strategy.BindingStatus
    public let needMoreRiskProfile: Swift.Bool
    public let needMoreMoney: Swift.Bool
  }
  public enum BindingStatus {
    case binded
    case unbinded
    case binding
    case unbinding
    public static func == (a: BrokerData.Strategy.BindingStatus, b: BrokerData.Strategy.BindingStatus) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum BindingType {
    case autoFollow
    case autoConsult
    public static func == (a: BrokerData.Strategy.BindingType, b: BrokerData.Strategy.BindingType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public struct ClientInvestProfile {
  public let id: Swift.Int
  public let name: Swift.String
}
extension Strategy : Swift.Hashable {
  public static func == (lhs: BrokerData.Strategy, rhs: BrokerData.Strategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Strategy.ClientAccountAvailability {
  public func `is`(account: BrokerData.Account) -> Swift.Bool
}
final public class MBIISService : APICore.APIService<BrokerData.MBIISService.Methods, BrokerData.MBServiceConfigurator> {
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    public typealias AgreementId = Swift.String
    case createAgreement
    case getAgreementStatus(APICore.MethodLocation)
    case getAgreement(APICore.MethodLocation)
    case agreementAccept(BrokerData.MBIISService.Methods.AgreementId)
    case agreementSMSResend(BrokerData.MBIISService.Methods.AgreementId)
    case agreementConclude(Swift.String, BrokerData.MBIISService.Methods.AgreementId)
    case getAgreementConcludeStatus(APICore.MethodLocation)
  }
  required public init()
  @objc deinit
}
extension MBIISService.Methods : Moya.AccessTokenAuthorizable {
  public var authorizationType: Moya.AuthorizationType {
    get
  }
}
extension MBIISService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension MBIISService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case createAgreement
    case getAgreementStatus
    case getAgreement
    case agreementAccept
    case agreementSMSResend
    case agreementConclude
    case getAgreementConcludeStatus
    public typealias AllCases = [BrokerData.MBIISService.Methods.MockKey]
    public static var allCases: [BrokerData.MBIISService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.MBIISService.Methods.MockKey? {
    get
  }
}
extension MBIISService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public struct Coupon {
  public let rate: Swift.Double
  public let amount: Swift.Double
  public let currency: BrokerData.Currency
  public let paymentDate: Foundation.Date
}
public struct BankAccountChanges {
  public let bank: BrokerData.Bank
  public let account: BrokerData.Account
  public let accountNumber: Swift.String
  public let payee: Swift.String
  public init(bank: BrokerData.Bank, account: BrokerData.Account, accountNumber: Swift.String, payee: Swift.String)
}
extension BroData.Account {
  public struct Withdraw {
    public typealias RequestId = BrokerData.ETWithdrawService.UserRequestId
    public struct NewWithdrawOrder {
      public init(from: BrokerData.Account, to: BrokerData.BankAccount, tradeFloor: BrokerData.TradeFloor)
    }
    public enum BusinessError : Swift.Error {
      case error(message: Swift.String)
    }
  }
}
extension BroData.Account.Withdraw {
  public static func newWithdrawOrder(params: BrokerData.BroData.Account.Withdraw.NewWithdrawOrder, amount: Swift.Double) -> RxSwift.Single<[BrokerData.WithdrawOrder]>
  public static func newWithdrawOrderAll(params: BrokerData.BroData.Account.Withdraw.NewWithdrawOrder) -> RxSwift.Single<[BrokerData.WithdrawOrder]>
  public static func requestConfirmationSmsCode(order: BrokerData.WithdrawOrder) -> RxSwift.Single<Swift.Void>
  public static func confirmRequest(code: Swift.String, order: BrokerData.WithdrawOrder) -> RxSwift.Single<Swift.Void>
}
final public class BRSService : APICore.APIService<BrokerData.BRSService.Methods, BrokerData.BRSConfigurator> {
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case getQrCode(BrokerData.BRSService.Methods.GetQRCodeParams)
  }
  required public init()
  @objc deinit
}
extension BRSService.Methods : Moya.AccessTokenAuthorizable {
  public var authorizationType: Moya.AuthorizationType {
    get
  }
}
extension BRSService.Methods : APICore.APIServiceMethod {
  public var headers: [Swift.String : Swift.String]? {
    get
  }
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension BRSService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case getQrCode
    public typealias AllCases = [BrokerData.BRSService.Methods.MockKey]
    public static var allCases: [BrokerData.BRSService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.BRSService.Methods.MockKey? {
    get
  }
}
extension BRSService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
extension BroData {
  public struct IIA {
  }
}
@objc final public class MoneyConverter : Foundation.UnitConverter {
  public static var usd: BrokerData.MoneyConverter
  public static var eur: BrokerData.MoneyConverter
  final public var exchangeRate: Swift.Double
  @objc override final public func baseUnitValue(fromValue value: Swift.Double) -> Swift.Double
  @objc override final public func value(fromBaseUnitValue baseUnitValue: Swift.Double) -> Swift.Double
  @objc override dynamic public init()
  @objc deinit
}
public struct Best2PayPaymentComission {
  public let paymentId: Swift.String
  public let amount: Swift.Double
}
public struct Best2PayPayment {
  public let paymentId: Swift.String
  public let status: Swift.String
  public let acsurl: Swift.String
  public let termUrl: Swift.String
  public let md: Swift.String
  public let paReq: Swift.String
}
public struct PaymentPage {
  public let htmlData: Foundation.Data
}
public struct Best2PayPaymentStatus {
  public enum Status {
    case rejected
    case processed
    case executed
    case unknown
    public static func == (a: BrokerData.Best2PayPaymentStatus.Status, b: BrokerData.Best2PayPaymentStatus.Status) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let paymentId: Swift.String
  public let status: BrokerData.Best2PayPaymentStatus.Status
}
extension ETPortfelService {
  public struct PaymentDetailsResponse : Swift.Decodable {
    public let payee: Swift.String
    public let bank: Swift.String
    public let bIK: Swift.String
    public let iNN: Swift.String
    public let kPP: Swift.String
    public let accountNumber: Swift.String
    public let correspondentAccount: Swift.String
    public let purpose: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
}
public struct Alert {
  public let id: BrokerData.AlertId
  public let instrument: BrokerData.FinInstrument
  public let isActive: Swift.Bool
  public let date: Foundation.Date
  public let exerciseDate: Foundation.Date
  public let targetPrice: BrokerData.Price
  public let pointToTargetPrice: BrokerData.Price
}
extension ETTradingService {
  public struct Response : Swift.Decodable {
    public let orderId: BrokerData.ETTradingService.OrderId
    public init(from decoder: Swift.Decoder) throws
  }
  public struct ConfirmResponse : Swift.Decodable {
    public let orderId: BrokerData.ETTradingService.OrderId?
    public let message: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct InstrumentResponse : Swift.Decodable {
    public let factor: Swift.Double
    public let initialMargin: Swift.Double?
    public let notional: Swift.Double?
    public let aI: Swift.Double
    public let currency: BrokerData.ETCurrency
    public let canMarketOrder: Swift.Bool
    public let ask: Swift.Double
    public let bid: Swift.Double
    public init(from decoder: Swift.Decoder) throws
  }
  public struct CheckPinResponse : Swift.Decodable {
    public let status: Swift.Int
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SaveResponse : Swift.Decodable {
    public let orderRequestId: BrokerData.ETTradingService.OrderRequestId
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SetConfirmationOrderTypeSMSResponse : Swift.Decodable {
    public let status: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct SetConfirmationOrderTypePINResponse : Swift.Decodable {
    public let userRequestId: BrokerData.ETTradingService.UserRequestId
    public init(from decoder: Swift.Decoder) throws
  }
  public struct OrderResponse : Swift.Decodable {
    public let exchStatus: Swift.Int
    public let error: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
}
public enum TradePasswordCheckResult {
  case incorrect
  case passwordInvalidated
  case correct
  public static func == (a: BrokerData.TradePasswordCheckResult, b: BrokerData.TradePasswordCheckResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct BankAccount {
  public let client: BrokerData.Client
  public let bank: BrokerData.Bank
  public let currencyCode: Swift.String
  public let account: Swift.String
  public let payee: Swift.String
  public let payeeType: Swift.Int
  public let inn: Swift.String?
  public let status: Swift.Int
  public let statusDescription: Swift.String?
}
extension BankAccount : Swift.Hashable {
  public static func == (lhs: BrokerData.BankAccount, rhs: BrokerData.BankAccount) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ShortDobsService.Methods {
  public enum ClientServiceItemParams : Swift.String, Swift.CaseIterable {
    case remote
    case broker
    case iis
    case trust
    public static var `default`: [BrokerData.ShortDobsService.Methods.ClientServiceItemParams] {
      get
    }
    public static var withIIS: [BrokerData.ShortDobsService.Methods.ClientServiceItemParams] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public typealias AllCases = [BrokerData.ShortDobsService.Methods.ClientServiceItemParams]
    public static var allCases: [BrokerData.ShortDobsService.Methods.ClientServiceItemParams] {
      get
    }
  }
  public enum PassportPageType : Swift.String {
    case first, registration
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias ConfirmationAnketaDataParams = (address: Swift.String, domicileSameAsResidence: Swift.Bool, confirmationOfPersonalData: Swift.Bool)
  public typealias SourceIncomeAnketaParams = (agree: Swift.Bool, confirmation: Swift.Bool, sallary: Swift.Bool, business: Swift.Bool, stocks: Swift.Bool, derivatives: Swift.Bool, forex: Swift.Bool, inheritance: Swift.Bool, donation: Swift.Bool, loan: Swift.Bool, another: Swift.Bool, anotherText: Swift.String?)
  public typealias PassportDataParams = (address: Swift.String, gender: Swift.String, firstName: Swift.String, middleName: Swift.String?, lastName: Swift.String, birthPlace: Swift.String, birthDate: Foundation.Date, series: Swift.String, issueDate: Foundation.Date, number: Swift.String, issuedBy: Swift.String, issueId: Swift.String)
  public typealias MobileNumberParams = (phone: Swift.String, fakeMode: Swift.Bool, partnerGuid: Swift.String, externalAcc: Swift.String)
  public typealias PassportImageParams = (source: BrokerData.ShortDobsService.Methods.PassportPageType, image: UIKit.UIImage)
}
extension ETWithdrawService.Methods {
  public struct BankAccountSaveParams {
    public let bankAccountId: Swift.Int
    public let clientId: Swift.Int
    public let bankId: Swift.Int
    public let bik: Swift.String
    public let currency: BrokerData.Currency
    public let account: Swift.String
    public let payee: Swift.String
    public let payeeType: Swift.Int
    public init(bankAccountId: Swift.Int, clientId: Swift.Int, bankId: Swift.Int, bik: Swift.String, currency: BrokerData.Currency, account: Swift.String, payee: Swift.String, payeeType: Swift.Int)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
  public struct WithdrawalSaveParams {
    public let bankAccountId: Swift.String
    public let type: Swift.Int
    public let isRest: Swift.Bool
    public let accountId: Swift.Int
    public let tradeFloorId: Swift.Int
    public let amount: Swift.Double?
    public init(amount: Swift.Double?, bankAccountId: Swift.String, type: Swift.Int, isRest: Swift.Bool, accountId: Swift.Int, tradeFloorId: Swift.Int)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
}
extension ETAuthService {
  public enum SignInResponse : Swift.Equatable {
    case ok(token: Swift.String)
    case tempPassword(token: Swift.String?)
    case noLogin
    case noPassword
    case generalError
    case notPostRequest
    case incorrectLoginPassword
    case incorrectConnectionLoginPassword
    case unknownMethod(Swift.Int)
    case networkError
    case unknownFailed(Swift.Int)
  }
}
public func == (lhs: BrokerData.ETAuthService.SignInResponse, rhs: BrokerData.ETAuthService.SignInResponse) -> Swift.Bool
extension ETAuthService.SignInResponse : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Measurement where UnitType == BrokerData.MoneyUnit {
  public func string(_ formatter: BrokerData.MoneyFormatter) -> Swift.String
  public func string(_ formatter: Foundation.NumberFormatter) -> Swift.String
  public func string(_ fractionDigits: Swift.Int) -> Swift.String
  public var string: Swift.String {
    get
  }
  public func string(unitStyle: Foundation.Formatter.UnitStyle = .short, _ configs: Foundation.NumberFormatter.Config...) -> Swift.String
  public func string(unitStyle: Foundation.Formatter.UnitStyle = .short, _ configs: [Foundation.NumberFormatter.Config]) -> Swift.String
}
public typealias ImageResource = BCSSwiftTools.ImageResource
public typealias ConfiguratorContainer = APICore.APICoreObjectContainer
public typealias DefaultConfigurator = APICore.DefaultAPIServiceConfigurator
public typealias APIRequestBuilder = APICore.RequestBuilder
public typealias NetworkPlugins = APICore.Plugins
public typealias TokenProvider = APICore.AuthTokenProvider
public typealias Token = APICore.AuthToken
public typealias ISIN = Swift.String
public typealias Id = Swift.Int
public typealias NewsId = BrokerData.Id
public typealias InvestIdeaId = BrokerData.Id
public typealias InstrumentId = BrokerData.Id
public typealias AuthorId = BrokerData.Id
public typealias AlertId = BrokerData.Id
public typealias OrderId = BrokerData.Id
public typealias TradeId = Swift.String
public typealias OperationId = BrokerData.Id
public typealias FMSInfo = Swift.String
public typealias FMSId = Swift.String
public typealias BCSCity = BrokerData.ETGeoService.CityItemResponse
public typealias OfficeParams = BrokerData.ETGeoService.Methods.ListParams
public typealias CategoryId = Swift.Int
public typealias OrderRequestId = Swift.Int
public typealias Status = Swift.Int
public typealias IdeaId = Swift.Int
public typealias AccountId = Swift.Int
public typealias ClientId = Swift.Int
public typealias UserRequestId = Swift.String
public typealias StrategyId = Swift.String
public typealias InstrumentTicker = Swift.String
public typealias PIN = Swift.String
public typealias Phone = Swift.String
public typealias APSDeviceToken = Swift.String
public protocol BroDataDelegate {
  func faq() -> RxSwift.Single<[BrokerData.FAQItem]>
}
public struct BroData {
  public enum ClientApp : Swift.String {
    case myBroker3
    case myBrokerX
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
  }
  public static var clientApp: BrokerData.BroData.ClientApp
  public static var useMLBackendIFPossible: Swift.Bool
  public static var delegate: BrokerData.BroDataDelegate?
  public static var mlBackendOptions: BrokerData.BroData.ML
  public static var orderBookConfig: BrokerData.OrderBookProvider.Config {
    get
    set
  }
  public static let logger: BCSSwiftTools.Logger
}
extension BroData {
  public struct ML : Swift.OptionSet {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public static let search: BrokerData.BroData.ML
    public static let quoteList: BrokerData.BroData.ML
    public typealias Element = BrokerData.BroData.ML
    public typealias ArrayLiteralElement = BrokerData.BroData.ML
    public typealias RawValue = Swift.Int
  }
  public static func enabled(ml: BrokerData.BroData.ML) -> Swift.Bool
}
extension BroData {
  public static func bcsOffices(params: BrokerData.OfficeParams) -> RxSwift.Single<[BrokerData.BCSOffice]>
  public static func bcsCities() -> RxSwift.Single<[BrokerData.BCSCity]>
  public static func tradeFloors() -> RxSwift.Single<[BrokerData.TradeFloor]>
  public static func faq() -> RxSwift.Single<[BrokerData.FAQItem]>
  public static func banks(bankBik: Swift.String) -> RxSwift.Single<[BrokerData.Bank]>
  public static func suggestAdresses(query: Swift.String, maxCount: Swift.Int = 10) -> RxSwift.Single<[BrokerData.AddressSuggestion]>
  public static func suggestFms(fmsId: BrokerData.FMSId) -> RxSwift.Single<[BrokerData.FMSInfo]>
  public static func link(deviceToken: BrokerData.APSDeviceToken) -> RxSwift.Single<Swift.Void>
  public static func unlink(deviceToken: BrokerData.APSDeviceToken) -> RxSwift.Single<Swift.Void>
}
extension Best2PayService.Methods {
  public struct PaymentComissionParams {
    public enum Secret : Swift.String {
      case withCommission
      case withOutCommission
      public typealias RawValue = Swift.String
      public init?(rawValue: Swift.String)
      public var rawValue: Swift.String {
        get
      }
    }
    public init(amount: Swift.Double, fullName: Swift.String, account: BrokerData.Account, currency: BrokerData.Currency, secret: BrokerData.Best2PayService.Methods.PaymentComissionParams.Secret)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
  public struct AcceptPaymentParams {
    public struct PayerCard {
      public init(pan: Swift.String, month: Swift.String, year: Swift.String, cvc: Swift.String, name: Swift.String)
      public var asDictionary: [Swift.String : Any] {
        get
      }
    }
    public init(account: BrokerData.Account, fullName: Swift.String, paymentId: Swift.String, payerCard: BrokerData.Best2PayService.Methods.AcceptPaymentParams.PayerCard)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
  public struct PaymentPageParams {
    public init(md: Swift.String, paReq: Swift.String, termURL: Swift.String, acsurl: Swift.String)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
  public struct PaymentStatusParams {
    public init(paymentId: Swift.String)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
}
public class NewOrder : Swift.CustomStringConvertible {
  public var stateChanged: RxSwift.Observable<Swift.Void> {
    get
  }
  public init(_ tradingInfo: BrokerData.NewOrder.TradingInfo, draft: BrokerData.NewOrder.Draft? = nil)
  public func set(draft: BrokerData.NewOrder.Draft)
  public func updatePrices(tradingInfo: BrokerData.NewOrder.TradingInfo)
  final public let instrument: BrokerData.FinInstrument
  final public let maxLotsPerOrder: Swift.Int?
  final public let properies: BrokerData.FinInstrument.Properties
  final public let userProperties: BrokerData.FinInstrument.UserProperties
  public var prices: BrokerData.FinInstrument.Prices {
    get
    set
  }
  public var account: BrokerData.Account {
    get
    set
  }
  public var asset: BrokerData.Asset? {
    get
    set
  }
  public var tradingType: BrokerData.TradingType {
    get
    set
  }
  public var amountLots: Swift.Int? {
    get
    set
  }
  public var isEnoughMoney: Swift.Bool {
    get
  }
  public var amountIsValid: Swift.Bool {
    get
  }
  public var isValid: Swift.Bool {
    get
  }
  public var amountPieces: Swift.Int? {
    get
    }
  public var totalPrice1Piece: Swift.Double? {
    get
  }
  public var total: Swift.Double? {
    get
  }
  public var bestPrice: Swift.Double {
    get
  }
  public var defaultPrice: Swift.Double? {
    get
  }
  public var totalMoney: BrokerData.Money? {
    get
  }
  public var totalMarginMoney: BrokerData.Money? {
    get
  }
  public var cost: BrokerData.Money? {
    get
  }
  public var isRequiredGreaterThenAvailable: Swift.Bool {
    get
  }
  public var totalType: BrokerData.NewOrder.TotalType {
    get
  }
  public var laverageAvailable: Swift.Bool {
    get
  }
  public var requiredMoney: BrokerData.Money? {
    get
  }
  public var hasLack: Swift.Bool {
    get
  }
  public var piecesLack: Swift.Int? {
    get
  }
  public var moneyLack: BrokerData.Money? {
    get
  }
  public var availableMoney: BrokerData.Money {
    get
  }
  public var leverage: BrokerData.NewOrder.Leverage? {
    get
  }
  public var accruedInterest: BrokerData.Money? {
    get
  }
  public var accruedInterestTotal: BrokerData.Money? {
    get
  }
  @objc deinit
}
extension NewOrder {
  public enum TotalType {
    case price
    case margin
    public static func == (a: BrokerData.NewOrder.TotalType, b: BrokerData.NewOrder.TotalType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct TradingInfo {
    public var quote: BrokerData.FinQuote
    public let properies: BrokerData.FinInstrument.Properties, userProperties: BrokerData.FinInstrument.UserProperties, finInfo: BrokerData.FinInfo
    mutating public func set(quote: BrokerData.FinQuote)
  }
  public struct Draft {
    public let asset: BrokerData.Asset?, amountLots: Swift.Int?, account: BrokerData.Account, tradingType: BrokerData.TradingType
    public init(asset: BrokerData.Asset?, amountLots: Swift.Int?, account: BrokerData.Account, tradingType: BrokerData.TradingType)
  }
  public enum Leverage {
    case short
    case money
    public static func == (a: BrokerData.NewOrder.Leverage, b: BrokerData.NewOrder.Leverage) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public class Field<TNewOrder, TValue> where TNewOrder : BrokerData.NewOrder {
    public var value: TValue? {
      get
      set
    }
    @objc deinit
  }
}
final public class ActivationPrice : BrokerData.NewOrder.Field<BrokerData.NewOrder, Swift.Double> {
  public enum Invalid {
    case shouldBeGreatLastPrice
    case shouldBeLessLastPrice
    case priceStepIssue
    public static func == (a: BrokerData.ActivationPrice.Invalid, b: BrokerData.ActivationPrice.Invalid) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public var money: BrokerData.Money? {
    get
  }
  final public var invalid: BrokerData.ActivationPrice.Invalid? {
    get
  }
  final public var isValid: Swift.Bool {
    get
  }
  @objc deinit
}
extension FinTargetService {
  public struct StrategiesResponse : Swift.Decodable {
    public let success: Swift.Bool
    public let errorCode: Swift.Int
    public let errorMessage: Swift.String?
    public let response: [BrokerData.FinTargetService.StrategyItem]?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct StrategyResponse : Swift.Decodable {
    public let success: Swift.Bool
    public let errorCode: Swift.Int
    public let errorMessage: Swift.String?
    public let response: BrokerData.FinTargetService.StrategyItem?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct BindResponse : Swift.Decodable {
    public let success: Swift.Bool
    public let errorCode: Swift.Int
    public let errorMessage: Swift.String?
    public let response: BrokerData.FinTargetService.AcceptHtmlItem?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct ClientProfileResponse : Swift.Decodable {
    public let success: Swift.Bool
    public let errorCode: Swift.Int
    public let errorMessage: Swift.String?
    public let response: BrokerData.FinTargetService.ClientProfileItem?
    public init(from decoder: Swift.Decoder) throws
  }
  public struct StrategyItem : Swift.Decodable {
    public let id: Swift.String
    public let name: Swift.String
    public let estimatedProfit: Swift.Double?
    public let rating: Swift.Double?
    public let minInvestProfile: BrokerData.FinTargetService.StrategyItem.InvestProfile
    public let pictureBase64: BrokerData.FinTargetBase64Image?
    public let author: BrokerData.FinTargetService.StrategyItem.AuthorItem
    public let tag: Swift.String?
    public let infoHtml: Swift.String?
    public let descriptionHtml: Swift.String?
    public let estimatedDrawdown: Swift.Double?
    public let subscriptionThreshold: Swift.Double?
    public let actualProfit: Swift.Double?
    public let currency: BrokerData.FinTargetService.FinTargetCurrency?
    public let minInvestCalculation: Swift.Int?
    public let maxIndustryWeight: Swift.Int?
    public let maxPositionWeight: Swift.Int?
    public let isAlgostrategy: Swift.Bool?
    public let leverage: Swift.Int?
    public let positionsCount: Swift.Double?
    public let actualDrawdown: Swift.Double?
    public let toolDrawndown: Swift.Double?
    public let open: Swift.Bool?
    public let showFullPortfolio: Swift.Bool?
    public let iis: Swift.Bool?
    public let recommended: Swift.Bool?
    public let autofollow: Swift.Bool?
    public let autoconsult: Swift.Bool?
    public let price: Swift.String?
    public let chartComment: Swift.String?
    public let cpacity: Swift.Int?
    public let startDate: Foundation.Date?
    public let clientAccountsAvailability: [BrokerData.FinTargetService.StrategyItem.ClientAccountAvailabilityItem]
    public let duration: BrokerData.FinTargetService.StrategyItem.Duration?
    public struct Duration : Swift.Decodable {
      public let days: Swift.Int?
      public let name: Swift.String?
      public init(from decoder: Swift.Decoder) throws
    }
    public struct AuthorItem : Swift.Decodable {
      public let id: Swift.Int
      public let email: Swift.String?
      public let position: Swift.String?
      public let company: Swift.String?
      public let firstName: Swift.String?
      public let middleName: Swift.String?
      public let lastName: Swift.String?
      public let infoHtml: Swift.String?
      public let photoBase64: BrokerData.FinTargetBase64Image?
      public init(from decoder: Swift.Decoder) throws
    }
    public struct InvestProfile : Swift.Decodable {
      public let id: Swift.Int
      public let profileId: Swift.String?
      public let name: Swift.String?
      public let description: Swift.String?
      public init(from decoder: Swift.Decoder) throws
    }
    public struct ClientAccountAvailabilityItem : Swift.Decodable {
      public let agreementNumber: Swift.String?
      public let agreementId: Swift.String?
      public let bindingStatus: Swift.Int
      public let canBeBound: Swift.Bool?
      public let bindingProhibitionReasons: [BrokerData.FinTargetService.StrategyItem.ClientAccountAvailabilityItem.Reason]?
      public struct Reason : Swift.Decodable {
        public let reason: Swift.String?
        public let code: Swift.Int
        public init(from decoder: Swift.Decoder) throws
      }
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct ClientProfileItem : Swift.Decodable {
    public let id: Swift.Int
    public let name: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct AcceptHtmlItem : Swift.Decodable {
    public let acceptHtml: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct FinTargetCurrency : Swift.Decodable {
    public let id: Swift.String?
    public init(from decoder: Swift.Decoder) throws
  }
}
public struct FinTargetBase64Image : Swift.Decodable {
  public let image: UIKit.UIImage?
  public let resource: BrokerData.ImageResource?
  public init(from decoder: Swift.Decoder) throws
}
final public class ShortDobsService : APICore.APIService<BrokerData.ShortDobsService.Methods, BrokerData.ShortDobsServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case mobileNumber(BrokerData.ShortDobsService.Methods.MobileNumberParams)
    case requestValidationCode
    case validationCode(code: Swift.String)
    case passportImage(BrokerData.ShortDobsService.Methods.PassportImageParams)
    case sourceIncomeAnketa(BrokerData.ShortDobsService.Methods.SourceIncomeAnketaParams)
    case requestAnketaData
    case clientemail(email: Swift.String)
    case refuseanketadata
    case confirmAnketaData(BrokerData.ShortDobsService.Methods.ConfirmationAnketaDataParams)
    case requeststatus
    case requestPrintForm
    case requestSignCode
    case passportData(BrokerData.ShortDobsService.Methods.PassportDataParams)
    case signCode(code: Swift.String)
    case clientServices([BrokerData.ShortDobsService.Methods.ClientServiceItemParams])
    case clientServicesList
    case clienttin(inn: Swift.String)
    case esiaPage(returnURL: Swift.String)
    case requestesiadata
    case optionalPassportImage(BrokerData.ShortDobsService.Methods.PassportImageParams)
  }
  required public init()
  @objc deinit
}
extension ShortDobsService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
  public var multipart: APICore.BinaryData? {
    get
  }
  public var overrideBodyEncoding: APICore.BodyEncoding? {
    get
  }
}
extension ShortDobsService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case mobileNumber
    case requestValidationCode
    case validationCode
    case passportImage
    case sourceIncomeAnketa
    case requestAnketaData
    case clientemail
    case confirmAnketaData
    case requestPrintForm
    case requestSignCode
    case signCode
    case requeststatus
    case refuseanketadata
    case passportData
    case clientService
    case clientServicesList
    case clienttin
    case esiaPage
    case requestesiadata
    case optionalPassportImage
    public typealias AllCases = [BrokerData.ShortDobsService.Methods.MockKey]
    public static var allCases: [BrokerData.ShortDobsService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ShortDobsService.Methods.MockKey? {
    get
  }
}
public struct Portfel {
  public let accounts: [BrokerData.Account]
  public let items: [BrokerData.PortfelItem]
  public let cost: BrokerData.Money
  public let finResult: BrokerData.FinResult
  public let freeMoneyRUB: BrokerData.Money
  public let freeMoneyUSD: BrokerData.Money
  public let freeMoneyEUR: BrokerData.Money
  public init(items: [BrokerData.PortfelItem], accounts: [BrokerData.Account], costCurrency: BrokerData.Currency, period: BrokerData.Period)
}
extension ETInvestIdeasService {
  public struct Author : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Response : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
public struct ETCurrency : Swift.Decodable {
  public let name: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
final public class ETUserService : APICore.APIService<BrokerData.ETUserService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case settings
    case preferences([BrokerData.InstrumentId])
  }
  required public init()
  @objc deinit
}
extension ETUserService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETUserService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case settings
    case preferences
    public typealias AllCases = [BrokerData.ETUserService.Methods.MockKey]
    public static var allCases: [BrokerData.ETUserService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETUserService.Methods.MockKey? {
    get
  }
}
extension ETUserService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
extension TradingType {
  public var etId: Swift.Int {
    get
  }
  public init(etId: Swift.Int)
}
final public class OrderBookProvider {
  public enum Error : Swift.Error {
    case noData
    case incorrectSendJson
    case unknownInstrument
    case payloadIssue
    case unknown
    case noConnect
    public static func == (a: BrokerData.OrderBookProvider.Error, b: BrokerData.OrderBookProvider.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct Config : Swift.Equatable {
    public let url: Foundation.URL
    public static func == (a: BrokerData.OrderBookProvider.Config, b: BrokerData.OrderBookProvider.Config) -> Swift.Bool
  }
  final public var config: BrokerData.OrderBookProvider.Config {
    get
    }
  final public let logger: BCSSwiftTools.Logger
  final public var socketLogEnabled: Swift.Bool
  public static let shared: BrokerData.OrderBookProvider
  final public func set(authorizationToken: Swift.String?)
  final public func set(config: BrokerData.OrderBookProvider.Config)
  final public func observable(for instument: BrokerData.FinInstrument) -> RxSwift.Observable<BrokerData.OrderBook>
  @objc deinit
}
extension URL {
  public struct OrderBookWebSocker {
    public static let test: Foundation.URL
    public static let prodInternal: Foundation.URL
    public static let prod: Foundation.URL
  }
}
extension OrderBookProvider.Config {
  public static let defaultTest: BrokerData.OrderBookProvider.Config
  public static let prodInternal: BrokerData.OrderBookProvider.Config
  public static let prod: BrokerData.OrderBookProvider.Config
}
extension OrderBookProvider : Starscream.WebSocketAdvancedDelegate {
  final public func websocketDidConnect(socket: Starscream.WebSocket)
  final public func websocketDidDisconnect(socket: Starscream.WebSocket, error: Swift.Error?)
  final public func websocketDidReceiveMessage(socket: Starscream.WebSocket, text: Swift.String, response: Starscream.WebSocket.WSResponse)
  final public func websocketDidReceiveData(socket: Starscream.WebSocket, data: Foundation.Data, response: Starscream.WebSocket.WSResponse)
  final public func websocketHttpUpgrade(socket: Starscream.WebSocket, request: Swift.String)
  final public func websocketHttpUpgrade(socket: Starscream.WebSocket, response: Swift.String)
}
extension Logger.Scope {
  public static let orderBook: BCSSwiftTools.Logger.Scope
}
extension Logger {
  public static var orderBook: BCSSwiftTools.Logger {
    get
  }
}
extension MLService {
  public struct MLResponse<DT> : Swift.Decodable where DT : Swift.Decodable {
    public let data: DT?
    public let errors: [BrokerData.MLService.MLError]?
    public func dataOrThrow() throws -> DT
    public init(from decoder: Swift.Decoder) throws
  }
  public struct MLError : Swift.Error, Swift.Decodable {
    public let message: Swift.String
    public let code: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct MLInstrument : Swift.Decodable {
    public let secCode: Swift.String
    public let shortName: Swift.String
    public let exDestinations: [BrokerData.MLService.MLExDestination]
    public init(from decoder: Swift.Decoder) throws
  }
  public struct MLExDestination : Swift.Decodable {
    public let exDestination: Swift.String
    public let isMarket: Swift.Bool
    public init(from decoder: Swift.Decoder) throws
  }
  public struct InstrumentGroupResp : Swift.Decodable {
    public let groupList: BrokerData.MLService.InstrumentGroup
    public let groupItem: [BrokerData.MLService.MLInstrument]
    public init(from decoder: Swift.Decoder) throws
  }
  public struct MLSuggestedInstrument : Swift.Decodable {
    public let ticker: Swift.String
    public let boards: [Swift.String]
    public let shortName: Swift.String
    public let type: Swift.String
    public let isin: BrokerData.ISIN
    public let regCode: Swift.String
    public let issuerName: Swift.String
    public let instrumentType: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
}
extension Logger.Scope {
  public static let molodcov: BCSSwiftTools.Logger.Scope
}
public struct BoolInt : Swift.ExpressibleByBooleanLiteral, Swift.Decodable {
  public typealias BooleanLiteralType = Swift.Bool
  public let bool: Swift.Bool
  public init(booleanLiteral value: BrokerData.BoolInt.BooleanLiteralType)
  public init(from decoder: Swift.Decoder) throws
}
public struct Order {
  public let id: BrokerData.OrderId
  public let instrument: BrokerData.FinInstrument
  public let orderStatus: BrokerData.OrderStatus
  public let createAt: Foundation.Date
  public let orderType: BrokerData.OrderType
  public let tradingType: BrokerData.TradingType
  public let amount: Swift.Double
  public let price: BrokerData.Price
  public let stopPrice: BrokerData.Price?
  public let payment: BrokerData.Money
  public let account: BrokerData.Account?
}
public enum OrderConfirmType : Swift.String, Swift.Codable {
  case sms
  case password
  case unknown
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum OrderType : Swift.CaseIterable {
  case limit
  case market
  case stopLimit
  case takeProfit
  case unknown
  public typealias AllCases = [BrokerData.OrderType]
  public static var allCases: [BrokerData.OrderType] {
    get
  }
  public static func == (a: BrokerData.OrderType, b: BrokerData.OrderType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum OrderStatus : Swift.Equatable {
  public typealias StatusCode = Swift.String
  public typealias Description = Swift.String
  public static func == (lhs: BrokerData.OrderStatus, rhs: BrokerData.OrderStatus) -> Swift.Bool
  case active
  case sending
  case executed
  case partiallyExecuted
  case canceled(BrokerData.OrderStatus.StatusCode)
  case rejected(BrokerData.OrderStatus.RejectedReаson)
  case unknown(BrokerData.OrderStatus.StatusCode, BrokerData.OrderStatus.Description?)
  public enum RejectedReаson {
    case creditLimitExceeded
    case unknown(BrokerData.OrderStatus.StatusCode, BrokerData.OrderStatus.Description?)
    public var description: Swift.String? {
      get
    }
  }
}
public enum OrderSource {
  case investIdea(BrokerData.InvestIdea)
  case news(BrokerData.News)
}
extension Order : Swift.Equatable {
  public static func == (lhs: BrokerData.Order, rhs: BrokerData.Order) -> Swift.Bool
}
extension Order {
  public init(newOrder: BrokerData.NewOrder, orderId: BrokerData.OrderId, status: BrokerData.OrderStatus, createdAt: Foundation.Date)
}
extension BRSService.Methods {
  public struct GetQRCodeParams {
    public init(amount: Swift.Double, fullName: Swift.String, sourceId: Swift.String, account: BrokerData.Account)
    public var asDictionary: [Swift.String : Any] {
      get
    }
  }
}
final public class DDServiceConfigurator : APICore.APIServiceConfiguratorType, APICore.APIServiceConfiguratorDelegate {
  final public var requestsErrorBehavior: APICore.RequestErrorBehavior?
  final public var sessionManager: APICore.SessionManager
  final public let bodyEncoding: APICore.MethodBodyEncoding
  final public let baseUrl: Foundation.URL
  final public var plugins: [APICore.Plugin]
  final public let baseHeaders: [Swift.String : Swift.String]?
  weak final public var delegate: APICore.APIServiceConfiguratorDelegate?
  final public var token: Swift.String?
  public init(plugins: [APICore.Plugin] = [], secret: Swift.String)
  final public func isUnauthorized(response: Moya.Response) -> Swift.Bool
  @objc deinit
}
final public class Best2PayService : APICore.APIService<BrokerData.Best2PayService.Methods, BrokerData.Best2PayConfigurator> {
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case comission(BrokerData.Best2PayService.Methods.PaymentComissionParams)
    case accept(BrokerData.Best2PayService.Methods.AcceptPaymentParams)
    case paymentPage(BrokerData.Best2PayService.Methods.PaymentPageParams)
    case status(BrokerData.Best2PayService.Methods.PaymentStatusParams)
  }
  required public init()
  @objc deinit
}
extension Best2PayService.Methods : Moya.AccessTokenAuthorizable {
  public var authorizationType: Moya.AuthorizationType {
    get
  }
}
extension Best2PayService.Methods : APICore.APIServiceMethod {
  public var overrideBaseURL: Foundation.URL? {
    get
  }
  public var overrideBodyEncoding: APICore.BodyEncoding? {
    get
  }
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension Best2PayService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case comission
    case accept
    case status
    case paymentPage
    public typealias AllCases = [BrokerData.Best2PayService.Methods.MockKey]
    public static var allCases: [BrokerData.Best2PayService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.Best2PayService.Methods.MockKey? {
    get
  }
}
extension Best2PayService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public class NewLimitOrder : BrokerData.NewOrder {
  public var price: Swift.Double? {
    get
    set
  }
  public var isCorrectPrice: Swift.Bool {
    get
  }
  override public var defaultPrice: Swift.Double? {
    get
  }
  override public var isValid: Swift.Bool {
    get
  }
  public init(_ tradingInfo: BrokerData.NewOrder.TradingInfo, draft: BrokerData.NewOrder.Draft? = nil, price: Swift.Double? = nil)
  override public init(_ tradingInfo: BrokerData.NewOrder.TradingInfo, draft: BrokerData.NewOrder.Draft? = super)
  @objc deinit
}
final public class ETNPSService : APICore.APIService<BrokerData.ETNPSService.Methods, BrokerData.ETServiceConfigurator> {
  public typealias UserRequestId = Swift.String
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case link(BrokerData.APSDeviceToken)
    case unlink(BrokerData.APSDeviceToken)
  }
  required public init()
  @objc deinit
}
extension ETNPSService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETNPSService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case link
    case unlink
    public typealias AllCases = [BrokerData.ETNPSService.Methods.MockKey]
    public static var allCases: [BrokerData.ETNPSService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETNPSService.Methods.MockKey? {
    get
  }
}
extension ETNPSService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
final public class ETPasswordService : APICore.APIService<BrokerData.ETPasswordService.Methods, BrokerData.ETPasswordServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case validatePassword(Swift.String)
    case changeTempPasswordPrepare(password: Swift.String, question: Swift.String, answer: Swift.String)
    case changeTempPasswordConfirm(sessionId: Swift.String, code: Swift.String)
  }
  required public init()
  @objc deinit
}
extension ETPasswordService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETPasswordService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case validatePassword
    case changeTempPasswordPrepare
    case changeTempPasswordConfirm
    public typealias AllCases = [BrokerData.ETPasswordService.Methods.MockKey]
    public static var allCases: [BrokerData.ETPasswordService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETPasswordService.Methods.MockKey? {
    get
  }
}
extension ETPasswordService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public enum TradingType : Swift.CaseIterable {
  case buy
  case sell
  public static func == (a: BrokerData.TradingType, b: BrokerData.TradingType) -> Swift.Bool
  public typealias AllCases = [BrokerData.TradingType]
  public static var allCases: [BrokerData.TradingType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension KeyCloakService {
  public struct JWT : Swift.Decodable, Swift.Encodable {
    public let token: Swift.String
    public let claims: BrokerData.KeyCloakService.JWT.Claims
    public struct Claims : Swift.Codable {
      public let isTemporaryPassword: Swift.Bool
      public let expiredAt: Foundation.Date?
      public static let unknown: BrokerData.KeyCloakService.JWT.Claims
      public init(from decoder: Swift.Decoder) throws
      public func encode(to encoder: Swift.Encoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
    public init(token: Swift.String, claims: BrokerData.KeyCloakService.JWT.Claims)
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct TokenResponse : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class FinQuoteProvider : BrokerData.SocketManager<BrokerData.FinQuoteProviderRequest, BrokerData.FinQuoteProviderResponse> {
  public typealias MarketData = (identifier: Swift.String, BrokerData.FinInstrument.Prices, BrokerData.TradeSessionPriceChange)
  public typealias FinInstrumentId = Swift.String
  final public var dispatchQueue: Dispatch.DispatchQueue {
    get
  }
  public static var instance: BrokerData.FinQuoteProvider?
  final public var servieLogEnabled: BrokerData.FinQuoteProvider.ServiceLog
  final public var autoReconnect: Swift.Bool
  final public var paused: Swift.Bool {
    get
    }
  public init(configurator: BrokerData.FinQuoteProvider.Configurator)
  @objc deinit
}
extension FinQuoteProvider : Starscream.WebSocketDelegate {
  final public func websocketDidConnect(socket: Starscream.WebSocketClient)
  final public func websocketDidDisconnect(socket: Starscream.WebSocketClient, error: Swift.Error?)
  final public func websocketDidReceiveMessage(socket: Starscream.WebSocketClient, text: Swift.String)
  final public func websocketDidReceiveData(socket: Starscream.WebSocketClient, data: Foundation.Data)
}
extension FinQuoteProvider {
  public struct Configurator {
    public let url: Foundation.URL
    public let tokenProvider: () -> BrokerData.SocketAuthToken?
    public init(url: Foundation.URL, tokenProvider: @escaping () -> BrokerData.SocketAuthToken?)
  }
  public struct ServiceLog : Swift.OptionSet {
    public let rawValue: Swift.Int
    public static let command: BrokerData.FinQuoteProvider.ServiceLog
    public static let quoteUpdate: BrokerData.FinQuoteProvider.ServiceLog
    public static let dictionary: BrokerData.FinQuoteProvider.ServiceLog
    public static let write: BrokerData.FinQuoteProvider.ServiceLog
    public static let recieve: BrokerData.FinQuoteProvider.ServiceLog
    public static let all: BrokerData.FinQuoteProvider.ServiceLog
    public init(rawValue: Swift.Int)
    public typealias Element = BrokerData.FinQuoteProvider.ServiceLog
    public typealias ArrayLiteralElement = BrokerData.FinQuoteProvider.ServiceLog
    public typealias RawValue = Swift.Int
  }
}
extension FinQuoteProvider {
  final public func observable(for instrument: BrokerData.FinInstrument) -> RxSwift.Observable<BrokerData.FinQuote>
  final public func pause(_ instruments: [BrokerData.FinInstrument])
  final public func resume(_ instruments: [BrokerData.FinInstrument])
  final public func pauseAll(_ instruments: [BrokerData.FinInstrument])
  final public func pause()
  final public func resume()
}
extension FinQuoteProvider {
  public static func setup(token: Swift.String)
}
public struct Client : Swift.Codable {
  public let identifier: Swift.Int
  public let fullName: Swift.String
  public static let unknown: BrokerData.Client
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Client : Swift.Hashable {
  public static func == (lhs: BrokerData.Client, rhs: BrokerData.Client) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ETNewsService {
  public struct Tag : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
  public struct Response : Swift.Decodable {
    public let body: Swift.String
    public let relatedNews: [BrokerData.ETNewsService.Response]?
    public let newsId: BrokerData.NewsId
    public let title: Swift.String
    public let date: Foundation.Date
    public let hasVideo: Swift.Bool?
    public let sourceName: Swift.String
    public let tags: [BrokerData.ETNewsService.Tag]?
    public let image: BrokerData.ETImage?
    public let announce: Swift.String?
    public let instrument: BrokerData.ETInstrument?
    public init(from decoder: Swift.Decoder) throws
  }
}
final public class ETDataService : APICore.APIService<BrokerData.ETDataService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case tradeFloor
    case bank(Swift.String)
  }
  required public init()
  @objc deinit
}
extension ETDataService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETDataService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case tradeFloor
    case bank
    public typealias AllCases = [BrokerData.ETDataService.Methods.MockKey]
    public static var allCases: [BrokerData.ETDataService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETDataService.Methods.MockKey? {
    get
  }
}
extension ETDataService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
public struct Change {
  public let absolute: Swift.Double
  public let percents: Swift.Double
  public let currency: BrokerData.Currency
  public init(absolute: Swift.Double? = nil, percents: Swift.Double? = nil, currency: BrokerData.Currency = .unknown)
  public static let zero: BrokerData.Change
  public static let unknown: BrokerData.Change
}
public typealias TradeSessionPriceChange = BrokerData.Change
public func + (lhs: BrokerData.Change, rhs: BrokerData.Change) -> BrokerData.Change
public struct DepositLimitInfo {
  public let contributionByMonth: Swift.Double
  public let contributionComission: Swift.Double
  public let contributionLimit: Swift.Double
  public let contributionRest: Swift.Double
  public let ucsLimit: Swift.Double
  public let marketingCampaign: BrokerData.MarketingCampaign?
}
public struct MarketingCampaign : Swift.Codable {
  public let dateTo: Foundation.Date
  public let contributionComission: Swift.Double
  public var isZeroComission: Swift.Bool {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension ETGeoService {
  public struct CityItemResponse : Swift.Decodable {
    public let id: Swift.Int
    public let name: Swift.String
    public init(from decoder: Swift.Decoder) throws
  }
  public struct ListItemResponse : Swift.Decodable {
    public init(from decoder: Swift.Decoder) throws
  }
}
public typealias FinKind = BrokerData.FinInstrument.Kind
extension FinInstrument {
  public enum Kind : Swift.String {
    case equity
    case usaEquity
    case future
    case option
    case bond
    case index
    case euroBond
    case fx
    case smallFx
    case money
    case pif
    case etf
    case notes
    case structProduct
    case unknown
    public static var allCases: [BrokerData.FinInstrument.Kind] {
      get
    }
    public var availableOrderTypes: [BrokerData.OrderType] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
extension FinInstrument.Kind {
  public enum LifeTime {
    case term
    case indefinite
    public static func == (a: BrokerData.FinInstrument.Kind.LifeTime, b: BrokerData.FinInstrument.Kind.LifeTime) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var lifeTime: BrokerData.FinInstrument.Kind.LifeTime {
    get
  }
  public var textCase: BCSSwiftTools.TextCase {
    get
  }
  public func isKind(_ kinds: BrokerData.FinInstrument.Kind...) -> Swift.Bool
}
extension FinInstrument.Kind : Swift.Equatable {
}
extension FinInstrument.Kind : Swift.Codable {
}
final public class ETInstrumentService : APICore.APIService<BrokerData.ETInstrumentService.Methods, BrokerData.ETServiceConfigurator> {
  override final public var urlServicePathComponent: Swift.String {
    get
  }
  override final public var authStrategy: APICore.AuthStrategy {
    get
  }
  public enum Methods {
    case coupons(BrokerData.InstrumentId)
    case summary(BrokerData.InstrumentId)
    case quotes(category: Swift.Int)
    case search(Swift.String)
    case addFavorite(BrokerData.InstrumentId, Swift.Bool)
    case devidends(BrokerData.InstrumentId)
    case setMyListOrder([BrokerData.InstrumentId])
  }
  required public init()
  @objc deinit
}
extension ETInstrumentService.Methods : APICore.APIServiceMethod {
  public var methodPath: APICore.MethodPath {
    get
  }
  public var params: APICore.MethodParams {
    get
  }
}
extension ETInstrumentService.Methods {
  public enum MockKey : Swift.String, APICore.MockKeyType {
    case quotes
    case search
    case summary
    case addFavorite
    case devidends
    case coupons
    case setMyListOrder
    public typealias AllCases = [BrokerData.ETInstrumentService.Methods.MockKey]
    public static var allCases: [BrokerData.ETInstrumentService.Methods.MockKey] {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var mockKey: BrokerData.ETInstrumentService.Methods.MockKey? {
    get
  }
}
extension ETInstrumentService.Methods.MockKey : APICore.MockSampleData {
  public var sampleData: Swift.String? {
    get
  }
}
final public class NewTakeProfitOrder : BrokerData.NewOrder {
  final public var activationPrice: BrokerData.ActivationPrice {
    get
    set
  }
  final public var offsetPercents: BrokerData.OffsetPercents {
    get
    set
  }
  final public var spreadPercents: BrokerData.SpreadPercents {
    get
    set
  }
  override final public var isValid: Swift.Bool {
    get
  }
  override public init(_ tradingInfo: BrokerData.NewOrder.TradingInfo, draft: BrokerData.NewOrder.Draft? = super)
  @objc deinit
}
final public class OffsetPercents : BrokerData.NewOrder.Field<BrokerData.NewTakeProfitOrder, Swift.Double> {
  public enum Invalid {
    case shouldBeInRange0to10
    public static func == (a: BrokerData.OffsetPercents.Invalid, b: BrokerData.OffsetPercents.Invalid) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public var money: BrokerData.Money? {
    get
  }
  final public var invalid: BrokerData.OffsetPercents.Invalid? {
    get
  }
  final public var isValid: Swift.Bool {
    get
  }
  @objc deinit
}
final public class SpreadPercents : BrokerData.NewOrder.Field<BrokerData.NewTakeProfitOrder, Swift.Double> {
  public enum Invalid {
    case shouldBeInRange0to10
    public static func == (a: BrokerData.SpreadPercents.Invalid, b: BrokerData.SpreadPercents.Invalid) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public var money: BrokerData.Money? {
    get
  }
  final public var invalid: BrokerData.SpreadPercents.Invalid? {
    get
  }
  final public var isValid: Swift.Bool {
    get
  }
  @objc deinit
}
extension BRSService {
  public struct GetQRCodeResponse : Swift.Decodable {
    public let sourceId: Swift.String?
    public let operationId: Swift.String?
    public let code: Swift.String?
    public let message: Swift.String?
    public let data: BrokerData.BRSService.GetQRCodeResponse.Data?
    public struct Data : Swift.Decodable {
      public let qrcId: Swift.String?
      public let payload: Swift.String?
      public let payloadBase64: Swift.String?
      public let status: Swift.String?
      public init(from decoder: Swift.Decoder) throws
    }
    public init(from decoder: Swift.Decoder) throws
  }
}
public typealias Tokens = BrokerData.BroData.Security.Tokens
extension BroData {
  public struct Security {
    public typealias DemoAccessToken = Swift.String
    public typealias AccessToken = BrokerData.KeyCloakService.JWT
    public typealias RefreshToken = Swift.String
    public struct Tokens : Swift.Codable {
      public let access: BrokerData.BroData.Security.AccessToken, refresh: BrokerData.BroData.Security.RefreshToken
      public init(access: BrokerData.BroData.Security.AccessToken, refresh: BrokerData.BroData.Security.RefreshToken)
      public init(access: Swift.String, refresh: BrokerData.BroData.Security.RefreshToken? = nil)
      public init(from decoder: Swift.Decoder) throws
      public func encode(to encoder: Swift.Encoder) throws
    }
    public enum AuthType {
      case keyCloack
      case effectiveTrade
      public static func == (a: BrokerData.BroData.Security.AuthType, b: BrokerData.BroData.Security.AuthType) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public static var authType: BrokerData.BroData.Security.AuthType
    public struct AuthCredential {
      public let login: Swift.String
      public let password: Swift.String
      public init(login: Swift.String, password: Swift.String)
      public static let k663000: BrokerData.BroData.Security.AuthCredential
    }
    public enum SecurityError : Swift.Error {
      case invalidCredential
      case refreshTokenExpired
      public static func == (a: BrokerData.BroData.Security.SecurityError, b: BrokerData.BroData.Security.SecurityError) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
  }
}
extension BroData.Security {
  public static func accessToken(with credential: BrokerData.BroData.Security.AuthCredential) -> RxSwift.Single<BrokerData.BroData.Security.Tokens>
  public static func accessToken(withRefreshToken token: Swift.String) -> RxSwift.Single<BrokerData.BroData.Security.Tokens>
  public static func demoAccessToken() -> RxSwift.Single<BrokerData.BroData.Security.DemoAccessToken>
  public static func oldSignIn(with credential: BrokerData.BroData.Security.AuthCredential) -> RxSwift.Single<BrokerData.BroData.Security.Tokens>
}
extension BrokerData.NonTradeOperation.Kind : Swift.Equatable {}
extension BrokerData.NonTradeOperation.Kind : Swift.Hashable {}
extension BrokerData.NewsCategory : Swift.Equatable {}
extension BrokerData.NewsCategory : Swift.Hashable {}
extension BrokerData.Account.Kind : Swift.Equatable {}
extension BrokerData.Account.Kind : Swift.Hashable {}
extension BrokerData.Account.Kind : Swift.RawRepresentable {}
extension BrokerData.OrderConfirmType : Swift.Equatable {}
extension BrokerData.OrderConfirmType : Swift.Hashable {}
extension BrokerData.OrderConfirmType : Swift.RawRepresentable {}
extension BrokerData.OrderBookItem.Kind : Swift.Equatable {}
extension BrokerData.OrderBookItem.Kind : Swift.Hashable {}
extension BrokerData.InvestIdeasCategory : Swift.Equatable {}
extension BrokerData.InvestIdeasCategory : Swift.Hashable {}
extension BrokerData.FinInstrument.Kind : Swift.Hashable {}
extension BrokerData.FinInstrument.Kind : Swift.RawRepresentable {}
extension BrokerData.FinInstrument.Properties.TradeState : Swift.Equatable {}
extension BrokerData.FinInstrument.Properties.TradeState : Swift.Hashable {}
extension BrokerData.SmallLot : Swift.Equatable {}
extension BrokerData.SmallLot : Swift.Hashable {}
extension BrokerData.MBIISService.Status : Swift.Equatable {}
extension BrokerData.MBIISService.Status : Swift.Hashable {}
extension BrokerData.MBIISService.Status : Swift.RawRepresentable {}
extension BrokerData.BroData.Session.Environment : Swift.Equatable {}
extension BrokerData.BroData.Session.Environment : Swift.Hashable {}
extension BrokerData.InvestIdea.Finished.Kind : Swift.Equatable {}
extension BrokerData.InvestIdea.Finished.Kind : Swift.Hashable {}
extension BrokerData.InvestIdea.State : Swift.Equatable {}
extension BrokerData.InvestIdea.State : Swift.Hashable {}
extension BrokerData.Strategy.BindingType : Swift.Equatable {}
extension BrokerData.Strategy.BindingType : Swift.Hashable {}
extension BrokerData.SignInDemoError : Swift.Equatable {}
extension BrokerData.SignInDemoError : Swift.Hashable {}
extension BrokerData.ETAuthProvider.AuthType : Swift.Equatable {}
extension BrokerData.ETAuthProvider.AuthType : Swift.Hashable {}
extension BrokerData.EcoSystemBCS.EcoSystem.Type : Swift.Equatable {}
extension BrokerData.EcoSystemBCS.EcoSystem.Type : Swift.Hashable {}
extension BrokerData.ETNotificationsService.Methods.AlertType : Swift.Hashable {}
extension BrokerData.ETNotificationsService.Methods.AlertType : Swift.RawRepresentable {}
extension BrokerData.FeatureAvailabilityKind : Swift.Equatable {}
extension BrokerData.FeatureAvailabilityKind : Swift.Hashable {}
extension BrokerData.BroData.Security.ChangeTempPassword.InvalidPasswordCause : Swift.Equatable {}
extension BrokerData.BroData.Security.ChangeTempPassword.InvalidPasswordCause : Swift.Hashable {}
extension BrokerData.OrderType : Swift.Equatable {}
extension BrokerData.OrderType : Swift.Hashable {}
extension BrokerData.Promo.CodingKeys : Swift.Equatable {}
extension BrokerData.Promo.CodingKeys : Swift.Hashable {}
extension BrokerData.Promo.CodingKeys : Swift.RawRepresentable {}
extension BrokerData.Promo.TimeFrame : Swift.Equatable {}
extension BrokerData.Promo.TimeFrame : Swift.Hashable {}
extension BrokerData.Promo.TimeFrame : Swift.RawRepresentable {}
extension BrokerData.ShortDobsService.RequestClientServicesListResponse.ClientServiceStatus : Swift.Equatable {}
extension BrokerData.ShortDobsService.RequestClientServicesListResponse.ClientServiceStatus : Swift.Hashable {}
extension BrokerData.MLService.InstrumentGroup : Swift.Equatable {}
extension BrokerData.MLService.InstrumentGroup : Swift.Hashable {}
extension BrokerData.MLService.InstrumentGroup : Swift.RawRepresentable {}
extension BrokerData.MLService.SortField : Swift.Equatable {}
extension BrokerData.MLService.SortField : Swift.Hashable {}
extension BrokerData.MLService.SortField : Swift.RawRepresentable {}
extension BrokerData.MLService.SortDirection : Swift.Equatable {}
extension BrokerData.MLService.SortDirection : Swift.Hashable {}
extension BrokerData.MLService.SortDirection : Swift.RawRepresentable {}
extension BrokerData.FinQuoteCategory : Swift.Equatable {}
extension BrokerData.FinQuoteCategory : Swift.Hashable {}
extension BrokerData.BroData.Portfel.EcoSystemError : Swift.Equatable {}
extension BrokerData.BroData.Portfel.EcoSystemError : Swift.Hashable {}
extension BrokerData.ETForecastService.Response.Key : Swift.Hashable {}
extension BrokerData.ETForecastService.Response.Key : Swift.RawRepresentable {}
extension BrokerData.Strategy.BindingStatus : Swift.Equatable {}
extension BrokerData.Strategy.BindingStatus : Swift.Hashable {}
extension BrokerData.Best2PayPaymentStatus.Status : Swift.Equatable {}
extension BrokerData.Best2PayPaymentStatus.Status : Swift.Hashable {}
extension BrokerData.TradePasswordCheckResult : Swift.Equatable {}
extension BrokerData.TradePasswordCheckResult : Swift.Hashable {}
extension BrokerData.ShortDobsService.Methods.ClientServiceItemParams : Swift.Equatable {}
extension BrokerData.ShortDobsService.Methods.ClientServiceItemParams : Swift.Hashable {}
extension BrokerData.ShortDobsService.Methods.ClientServiceItemParams : Swift.RawRepresentable {}
extension BrokerData.ShortDobsService.Methods.PassportPageType : Swift.Equatable {}
extension BrokerData.ShortDobsService.Methods.PassportPageType : Swift.Hashable {}
extension BrokerData.ShortDobsService.Methods.PassportPageType : Swift.RawRepresentable {}
extension BrokerData.BroData.ClientApp : Swift.Equatable {}
extension BrokerData.BroData.ClientApp : Swift.Hashable {}
extension BrokerData.BroData.ClientApp : Swift.RawRepresentable {}
extension BrokerData.Best2PayService.Methods.PaymentComissionParams.Secret : Swift.Equatable {}
extension BrokerData.Best2PayService.Methods.PaymentComissionParams.Secret : Swift.Hashable {}
extension BrokerData.Best2PayService.Methods.PaymentComissionParams.Secret : Swift.RawRepresentable {}
extension BrokerData.NewOrder.TotalType : Swift.Equatable {}
extension BrokerData.NewOrder.TotalType : Swift.Hashable {}
extension BrokerData.NewOrder.Leverage : Swift.Equatable {}
extension BrokerData.NewOrder.Leverage : Swift.Hashable {}
extension BrokerData.ActivationPrice.Invalid : Swift.Equatable {}
extension BrokerData.ActivationPrice.Invalid : Swift.Hashable {}
extension BrokerData.TradingType : Swift.Hashable {}
extension BrokerData.OrderBookProvider.Error : Swift.Equatable {}
extension BrokerData.OrderBookProvider.Error : Swift.Hashable {}
extension BrokerData.FinInstrument.Kind.LifeTime : Swift.Equatable {}
extension BrokerData.FinInstrument.Kind.LifeTime : Swift.Hashable {}
extension BrokerData.OffsetPercents.Invalid : Swift.Equatable {}
extension BrokerData.OffsetPercents.Invalid : Swift.Hashable {}
extension BrokerData.SpreadPercents.Invalid : Swift.Equatable {}
extension BrokerData.SpreadPercents.Invalid : Swift.Hashable {}
extension BrokerData.BroData.Security.AuthType : Swift.Equatable {}
extension BrokerData.BroData.Security.AuthType : Swift.Hashable {}
extension BrokerData.BroData.Security.SecurityError : Swift.Equatable {}
extension BrokerData.BroData.Security.SecurityError : Swift.Hashable {}
